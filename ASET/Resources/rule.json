[
  {
    "Id": "CDMV-79061",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB 데이터베이스는 모든 사용자, 그룹, 역할 및 기타 원칙을 위해 자동화와 계정 관리를 제공하는 조직-수준 인증/접근 메커니즘과 통합되어야 한다.",
    "Check": "CDMDB가 로그인이 없는 사용자를 가진 컨테인드 데이터베이스 사용을 허용하도록 구성되었는지 판단한다. SSMS Object Explorer에서, 데이터베이스 데이터베이스를 오른쪽-클릭 >> “Properties” 선택 >> “Advanced” 페이지를 선택한다. 만일 “Enabled Contained Database”가 “False”이면 조치가 필요하지 않다. SSMS Transact-SQL 편집기 같은 쿼리 인터페이스에서 다음과 같은 구문을 실행한다: “EXEC sp_configure 'contained database authentication” 만일 “config_value”와 “run_value” 컬럼의 리턴값이 “0”이면 조치가 필요하지 않다. CDMDB가 Windows 인증 만을 사용하도록 구성되었는지 판단한다. SSMS Object Explorer에서, 데이터베이스를 오른쪽-클릭하고, “Properties”를 선택하고, “Security” 페이지를 선택한다. 만일 “Windows Authentication Mode”가 선택되었다면 조치가 필요하지 않다. SSMS Transact-SQL 편집기 같은 쿼리 인터페이스에서 다음과 같은 구문을 실행한다: “SELECT CASE SERVERPROPERTY('IsIntegratedSecurityOnly') WHEN 1 THEN 'Windows Authentication' WHEN 0 THEN 'Windows and SQL Server Authentication' END as [Authentication Mode];” 만일 “Authentication Mode” 컬럼의 리턴값이 “Windows Authentication”이면 조치가 필요하지 않다. 혼합-모드(CDMDB 인증 및 Windows 인증)가 사용되는 경우, 혼합-모드의 필요성이 문서화되지 않고 승인되지 않는 한 조치가 필요하다. 관리 문서에서 CDMDB 관리가 인가된 계정 목록을 입수한다. CDMDB에서 실제로 관리되는 계정을 판단한다. 다음과 같은 구문을 실행한다. “SELECT name FROM sys.database_principals WHERE type_desc = 'SQL_USER' AND authentication_type_desc = 'DATABASE';” 만일 쿼리에 리스트 된 어떤 계정이 문서에 없다면, 조치가 필요하다. 이런 위험은 정보시스템보안담당자/정보시스템보안 관리자(ISSO/ISSM)가 승인해야 한다.",
    "Check_sql": [
      "EXEC sp_configure 'contained database authentication';",
      "SELECT CASE SERVERPROPERTY('IsIntegratedSecurityOnly') WHEN 1 THEN 'Windows Authentication' WHEN 0 THEN 'Windows and SQL Server Authentication' END as [Authentication Mode];",
      "SELECT name FROM sys.database_principals WHERE type_desc = 'SQL_USER' AND authentication_type_desc = 'DATABASE';"
    ],
    "Fix": "만일 혼합-모드가 필요하다면, 필요성과 근거를 문서화 한다. CDMDB 인증을 최소로 유지하는 대책을 서술하고, 패스워드를 보호하는 대책을 서술하며 사용된 SQL 로그인을 서술하고 관리자 승인을 받는다. 만일 혼합 보드가 필요하지 않다면, 다음과 같이 비활성화 한다: SSMS Object Explorer >> 데이터베이스를 오른쪽-클릭 >> “Properties”를 선택 >> “Security” 페이지를 선택한다. “Windows Authentication Mode”의 라디오버튼을 선택하고 “OK”를 클릭한다. CDMDB를 다시 시작한다. 다음과 같은 구문을 실행한다: “USE [master] EXEC xp_instance_regwrite N'HKEY_LOCAL_MACHINE', N'Software\\MS\\MSSQLServer\\MSSQLServer', N'LoginMode', REG_DWORD, 2 GO” CDMDB를 다시 시작한다. 각 계정이 CDMDB에서 관리되지만 필요하지 않을 경우, 사용자를 삭제하거나 비활성화 한다. 필요에 따라 적절하게 구성된 계정으로 대체한다. SSMS Object Explorer에서 사용자를 삭제한다: Database >> Security User >> User Name을 오른쪽-클릭 >> “Delete” 클릭. 쿼리를 통하여 사용자를 삭제: “USE database_name; DROP USER <user_name>;”.",
    "Fix_sql": [
      "USE [master] EXEC xp_instance_regwrite N'HKEY_LOCAL_MACHINE', N'Software\\MS\\MSSQLServer\\MSSQLServer', N'LoginMode', REG_DWORD, 2 GO;",
      "USE database_name;",
      "DROP USER <user_name>;"
    ]
  },
  {
    "Id": "CDMV-79065",
    "Risk": "H",
    "Status": "Ready",
    "Subject": "CDMDB는 가용한 접근 통제 정책에 따라 정보 및 시스템 자원의 논리적 접근에 승인된 인가를 강제해야 한다.",
    "Check": "사용자 별로 데이터베이스를 보안-개체 하기 위한 필요 보호 등급을 판단하기 위해 시스템 문서를 검토한다. 데이터베이스의 허가가 실제로 적절한지 검토한다. 만일 실제 허가가 문서화된 요구사항과 일치하지 않는다면 조치가 필요하다. 첨부 파일 \"Database permission assignments to users and roles.sql\"를 사용하기 바란다.",
    "Check_sql": null,
    "Fix": "데이터베이스-수준 보안-개체를 유지하도록 허가를 추가/삭제하기 위해 GRANT, REVOKE, DENY, ALTER ROLE, ADD MEMBER 및DROP MEMBER 구문을 사용한다. 수행 후 요구사항 문서에 반영한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79067",
    "Risk": "H",
    "Status": "Ready",
    "Subject": "CDMDB는 데이터베이스에 연결될 수 있는 명확하게 유일한 액티브 디렉터리 사용자 계정을 보장하여, 부정하게 부인하는 사용자에 대응하여 보호해야 한다.",
    "Check": "다음과 같은 쿼리를 수행한다: “SELECT name FROM sys.database_principals WHERE type in ('U','G') AND name LIKE '%$’;”'. 만일 사용자가 리턴되지 않는다면, 조치가 필요하지 않다. 만일 사용자가 리턴 된다면, 각 사용자가 컴퓨터 계정인지 여부를 판단한다. PowerShell을 기동하여 다음과 같은 코드를 실행한다: 주: <name>은 사용자의 username부분이다. 예를 들어, 만일 사용자가 \"CONTOSO\\user1$\"이면, username은 \"user1\"이다. “([ADSISearcher]\"(&(!ObjectCategory=Computer)(Name=<name>))\").FindAll()”. 만일 계정 정보가 리턴되지 않는다면, 조치가 필요하지 않다. 만일 계정 정보가 리턴 된다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name FROM sys.database_principals WHERE type in ('U','G') AND name LIKE '%$';"
    ],
    "Fix": "점검 SQL 구문으로 리턴된 모든 사용자를 삭제한다: “SELECT name FROM sys.database_principals WHERE type in ('U','G') AND name LIKE '%$;”. 사용자를 삭제하기 위해 각 사용자에게 다음과 같은 명령을 실행한다: “DROP USER [ IF EXISTS ] <user_name>;”",
    "Fix_sql": [
      "SELECT name FROM sys.database_principals WHERE type in ('U','G') AND name LIKE '%$;",
      "DROP USER [ IF EXISTS ] <user_name>;"
    ]
  },
  {
    "Id": "CDMV-79069",
    "Risk": "L",
    "Status": "Ready",
    "Subject": "CDMDB는 시스템-버전 테이블(임시 테이블) 사용을 부정하게 부인하는 사용자에 대응하여 보호해야 한다.",
    "Check": "테이블의 이력 버전을 수집/유지할 필요가 있는지 판단하기 위해 서버 문서를 점검한다. 필요가 없다면 조치가 필요하지 않다. 다음 쿼리를 사용하여 데이터베이스의 모든 임시 테이블을 찾는다. “SELECT SCHEMA_NAME(T.schema_id) AS schema_name, T.name AS table_name, T.temporal_type_desc, SCHEMA_NAME(H.schema_id) + '.' + H.name AS history_table FROM sys.tables T JOIN sys.tables H ON T.history_table_id = H.object_id WHERE T.temporal_type != 0 ORDER BY schema_name, table_name”. 시스템 문서를 사용하여, 어떤 테이블이 임시 테이블이 요구되는지 판단한다. 만일 문서에 열거된 테이블이 위 목록에 없다면, 조치가 필요하다. 마지막으로 레코드를 변경한 사용자나 로그인을 문서화 하는 필드가 존재해야 한다. 만일 존재하지 않는다면, 조치가 필요하다. 이력 보존 기간을 판단하기 위해 시스템 문서를 검토한다. Object Explorer >> 테이블을 오른쪽-클릭하고 “Script Table As”를 선택 >> “CREATE To” >> “New Query Editor” 윈도우. “SYSTEM_VERSIONING”를 가진 라인을 찾는다. \"HISTORY_RETENTION_PERIOD\"를 서술하는 텍스트를 찾는다. 만일 이 텍스트가 누락되거나, 문서화된 이력 보존 기간 보다 작다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT SCHEMA_NAME(T.schema_id) AS schema_name, T.name AS table_name, T.temporal_type_desc, SCHEMA_NAME(H.schema_id) + '.' + H.name AS history_table FROM sys.tables T JOIN sys.tables H ON T.history_table_id = H.object_id WHERE T.temporal_type != 0 ORDER BY schema_name, table_name;",
    ],
    "Fix": "시스템 버저닝을 활용하기 위해 기밀 테이블을 변경한다. 시스템 버저닝 기간을 정의하기 위해 비-임시 테이블을 변경한다. “ALTER TABLE InsurancePolicy ADD PERIOD FOR SYSTEM_TIME (SysStartTime, SysEndTime),  SysStartTime datetime2 GENERATED ALWAYS AS ROW START HIDDEN NOT NULL DEFAULT GETUTCDATE(),  SysEndTime datetime2 GENERATED ALWAYS AS ROW END HIDDEN NOT NULL DEFAULT CONVERT(DATETIME2, '9999-12-31 23:59:59.99999999');”. 이력 데이터를 1-년 보존으로 시스템 버저닝을 활성화 한다. “ALTER TABLE InsurancePolicy SET (SYSTEM_VERSIONING = ON (HISTORY_RETENTION_PERIOD = 1 YEAR));”. “https://msdn.MS.com/en-us/library/ms190273.aspx#Anchor_16”를 참조하기 바란다.",
    "Fix_sql": [
      "ALTER TABLE InsurancePolicy ADD PERIOD FOR SYSTEM_TIME (SysStartTime, SysEndTime),  SysStartTime datetime2 GENERATED ALWAYS AS ROW START HIDDEN NOT NULL DEFAULT GETUTCDATE(),  SysEndTime datetime2 GENERATED ALWAYS AS ROW END HIDDEN NOT NULL DEFAULT CONVERT(DATETIME2, '9999-12-31 23:59:59.99999999');",
      "ALTER TABLE InsurancePolicy SET (SYSTEM_VERSIONING = ON (HISTORY_RETENTION_PERIOD = 1 YEAR));"
    ]
  },
  {
    "Id": "CDMV-79071",
    "Risk": "H",
    "Status": "Ready",
    "Subject": "CDMDB는 데이터베이스가 신뢰 관계를 갖지 않도록 하여 부정하게 부인하는 사용자에 대응하여 보호해야 한다. ",
    "Check": "데이터베이스에 Trustworthy 속성이 설정되었는지 여부를 판단한다. “SELECT name as DatabaseName, SUSER_SNAME(owner_sid) AS DatabaseOwner, is_trustworthy_on FROM sys.databases”. 만일 Trustworthy 속성이 비활성화되었다면, 조치가 필요하지 않다. 만일 데이터베이스가 MSDB이고, Trustworthy가 활성화될 필요가 있다면, 조치가 필요하지 않다. 만일 Trustworthy가 활성화되면, 데이터베이스 소유자가 특권 계정인지 여부를 판단한다. “DECLARE @databaseOwner AS nvarchar(50) SET @databaseOwner = 'sa'”. “SELECT member.name AS Login, role.name AS Role FROM sys.server_principals member INNER JOIN sys.server_role_members rm ON member.principal_id = rm.member_principal_id INNER JOIN sys.server_principals role ON rm.role_principal_id = role.principal_id WHERE member.name = @databaseOwner  AND role.name IN ('sysadmin','securityadmin')”. “SELECT login.name, permission.permission_name FROM sys.server_principals login INNER JOIN sys.server_permissions permission ON login.principal_id = permission.grantee_principal_id WHERE login.name = @databaseOwner AND permission.permission_name IN ('CONTROL SERVER')”. 만일 데이터베이스 소유자가 특권 계정이면, 조치가 필요하다. 만일 데이터베이스 소유자가 특권 계정이 아니면, Trustworthy 속성이 필요하고 인가되었는지 여부를 판단하기 위해 시스템 문서를 검토한다. 만일 문서화되지 않았다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name as DatabaseName, SUSER_SNAME(owner_sid) AS DatabaseOwner, is_trustworthy_on FROM sys.databases;",
      "DECLARE @databaseOwner AS nvarchar(50) SET @databaseOwner = 'sa';",
      "SELECT member.name AS Login, role.name AS Role FROM sys.server_principals member INNER JOIN sys.server_role_members rm ON member.principal_id = rm.member_principal_id INNER JOIN sys.server_principals role ON rm.role_principal_id = role.principal_id WHERE member.name = @databaseOwner  AND role.name IN ('sysadmin','securityadmin');",
      "SELECT login.name, permission.permission_name FROM sys.server_principals login INNER JOIN sys.server_permissions permission ON login.principal_id = permission.grantee_principal_id WHERE login.name = @databaseOwner AND permission.permission_name IN ('CONTROL SERVER');"
    ],
    "Fix": "데이터베이스의 Trustworthy 속성을 비활성화 한다. “ALTER DATABASE [<database name>] SET TRUSTWORTHY OFF”.",
    "Fix_sql": [
      "ALTER DATABASE [<database name>] SET TRUSTWORTHY OFF;"
    ]
  },
  {
    "Id": "CDMV-79073",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB가 어떤 감사성 이벤트를 감사할지 선택하기 위해 ISSM이나 ISSM이 인정한 사용자/역할에만 허용해야 한다.",
    "Check": "시스템 문서에서 승인된 감사 유지 관리자 목록을 입수한다. 감사 명세를 생성하고 유지 관리하는 능력을 활성화 할 수 있는 다음 역할 멤버십을 가진 개별 사용자와 데이터베이스 역할을 검토한다: “db_owner”. 감사 정의를 생성하고 유지 관리하는 능력을 모두 활성화 할 수 있는 다음 허가를 가진 개별 사용자와 데이터베이스 역할을 검토한다: “ALTER ANY DATABASE AUDIT CONTROL”. 리스트된 허가를 가진 사용자/역할을 판단하기 위해 다음 쿼리를 사용한다: “SELECT DP.Name AS 'Database Principal', DbPerm.permission_name AS 'Granted ermission', R.name AS 'Role' FROM sys.database_principals DP LEFT OUTER JOIN sys.database_permissions DbPerm ON DP.principal_id = bPerm.grantee_principal_id LEFT OUTER JOIN sys.database_role_members DRM ON DP.principal_id = DRM.member_principal_id INNER JOIN sys.database_principals R ON DRM.role_principal_id = R.principal_id WHERE DbPerm.permission_name IN ('CONTROL','ALTER ANY DATABASE AUDIT')  OR R.name IN ('db_owner')”. 만일 리턴된 사용자/역할이 문서화되지 않은 허가를 가지거나, 문서화된 감사 유지 관리자가 허가를 가지지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "ALTER ANY DATABASE AUDIT CONTROL;",
      "SELECT DP.Name AS 'Database Principal', DbPerm.permission_name AS 'Granted ermission', R.name AS 'Role' FROM sys.database_principals DP LEFT OUTER JOIN sys.database_permissions DbPerm ON DP.principal_id = bPerm.grantee_principal_id LEFT OUTER JOIN sys.database_role_members DRM ON DP.principal_id = DRM.member_principal_id INNER JOIN sys.database_principals R ON DRM.role_principal_id = R.principal_id WHERE DbPerm.permission_name IN ('CONTROL','ALTER ANY DATABASE AUDIT')  OR R.name IN ('db_owner');"
    ],
    "Fix": "감사 유지 관리자에게 특화된 데이터베이스 역할을 생성하고 불필요한 허가 없이 감사를 유지 관리하는 허가를 제공한다(여기에서 사용된 역할 이름은 예제이고, 다른 이름을 사용할 수도 있음). “CREATE ROLE DATABASE_AUDIT_MAINTAINERS; GO GRANT ALTER ANY DATABASE AUDIT TO DATABASE_AUDIT_MAINTAINERS; GO”. 모든 사용자로부터 “ALTER ANY DATABASE AUDIT” 허가를 제거하기 위해 ” REVOKE, DENY, ALTER ROLE ..., DROP MEMBER ...” 구문을 사용한다. 그런 후에 각 인가된 데이터베이스 사용자에 관하여, 다음 구문을 실행한다: “ALTER ROLE DATABASE_AUDIT_MAINTAINERS ADD MEMBER; GO”. 필요하지 않은 로그인으로부터 CONTROL DATABASE 허가를 제거하기 위해 “REVOKE, DENY, ALTER SERVER ROLE ..., DROP MEMBER ...” 구문을 사용한다.",
    "Fix_sql": [
      "CREATE ROLE DATABASE_AUDIT_MAINTAINERS;",
      "GO GRANT ALTER ANY DATABASE AUDIT TO DATABASE_AUDIT_MAINTAINERS;",
      "GO;",
      "ALTER ANY DATABASE AUDIT;",
      "REVOKE, DENY, ALTER ROLE ..., DROP MEMBER ...;",
      "ALTER ROLE DATABASE_AUDIT_MAINTAINERS ADD MEMBER;",
      "GO;",
      "REVOKE, DENY, ALTER SERVER ROLE ..., DROP MEMBER ...;"
    ]
  },
  {
    "Id": "CDMV-79075",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 스토어드 프로시저, 함수 및 트리거를 포함하여 소프트웨어 모듈을 변경하는 권한을 제한해야 한다.",
    "Check": "서버 문서에서 스토어드 프로시저, 함수 및 트리거를 변경하도록 인가 받은 사용자/역할 목록을 입수한다. 각 사용자 데이터베이스에서 다음 쿼리를 실행한다: “SELECT P.type_desc AS principal_type, P.name AS principal_name, O.type_desc, CASE class WHEN 0 THEN DB_NAME() WHEN 1 THEN OBJECT_SCHEMA_NAME(major_id) + '.' +  OBJECT_NAME(major_id) WHEN 3 THEN SCHEMA_NAME(major_id) ELSE class_desc + '(' + CAST(major_id AS nvarchar) + ')' END AS securable_name, DP.state_desc, DP.permission_name FROM sys.database_permissions DP JOIN sys.database_principals P ON DP.grantee_principal_id = P.principal_id LEFT OUTER JOIN sys.all_objects O ON O.object_id = DP.major_id AND O.type IN 'TR','TA','P','','RF','PC','IF','FN','TF','U') WHERE DP.type IN ('AL','ALTG') AND DP.class IN (0, 1, 53);, SELECT R.name AS role_name, M.type_desc AS principal_type, M.name AS principal_name FROM sys.database_principals R JOIN sys.database_role_members DRM ON R.principal_id = DRM.role_principal_id JOIN sys.database_principals M ON DRM.member_principal_id = M.principal_id WHERE R.name IN ('db ddladmin','db_owner') AND M.name != 'dbo';”. 만일 리턴된 사용자/역할 허가가 명시된 오브젝트나 유형을 변경하기 위해 인가 받지 않았다면, 조치가 필요하다. 만일 사용자/역할 멤버십이 인가 받지 않았다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT P.type_desc AS principal_type, P.name AS principal_name, O.type_desc, CASE class WHEN 0 THEN DB_NAME() WHEN 1 THEN OBJECT_SCHEMA_NAME(major_id) + '.' +  OBJECT_NAME(major_id) WHEN 3 THEN SCHEMA_NAME(major_id) ELSE class_desc + '(' + CAST(major_id AS nvarchar) + ')' END AS securable_name, DP.state_desc, DP.permission_name FROM sys.database_permissions DP JOIN sys.database_principals P ON DP.grantee_principal_id = P.principal_id LEFT OUTER JOIN sys.all_objects O ON O.object_id = DP.major_id AND O.type IN 'TR','TA','P','','RF','PC','IF','FN','TF','U') WHERE DP.type IN ('AL','ALTG') AND DP.class IN (0, 1, 53);",
      "SELECT R.name AS role_name, M.type_desc AS principal_type, M.name AS principal_name FROM sys.database_principals R JOIN sys.database_role_members DRM ON R.principal_id = DRM.role_principal_id JOIN sys.database_principals M ON DRM.member_principal_id = M.principal_id WHERE R.name IN ('db ddladmin','db_owner') AND M.name != 'dbo';"
    ],
    "Fix": "인가 받지 않은 사용자/역할로부터 ALTER 허가를 REVOKE 한다: “REVOKE ALTER ON [<Object Name>] TO [<Principal Name>];”.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79077",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 데이터베이스 외부 소프트웨어의 링크, 스토어드 프로시저, 함수 및 트리거를 포함하여 소프트웨어 모듈을 변경하는 권한을 제한해야 한다.",
    "Check": "서버 문서에서 스키마 소유권 목록을 입수한다. 현재 스키마 소유권 목록을 입수하기 위해 다음 쿼리를 실행한다: SELECT S.name AS schema_name, P.name AS owning_principal FROM sys.schemas S JOIN sys.database_principals P ON S.principal_id = P.principal_id ORDER BY schema_name;”. 만일 스키마를 인가 받지 않은 데이터베이스 보안-주체가 소유하고 있다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT S.name AS schema_name, P.name AS owning_principal FROM sys.schemas S JOIN sys.database_principals P ON S.principal_id = P.principal_id ORDER BY schema_name;"
    ],
    "Fix": "데이터베이스 스키마 소유권을 인가된 데이터베이스 보안-주체로 전환한다: “ALTER AUTHORIZATION ON SCHEMA::[<Schema Name>] TO [<Principal Name>];”",
    "Fix_sql": [
      "ALTER AUTHORIZATION ON SCHEMA::[<Schema Name>] TO [<Principal Name>];"
    ]
  },
  {
    "Id": "CDMV-79079",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB 데이터베이스 오브젝트(테이블, 스토리지, 스토어드 프로시저, 함수, 트리거, CDMDB 외부 소프트웨어 링크)는 소유권을 가진 데이터베이스 보안-주체에 의해 소유되어야 한다.",
    "Check": "자체 데이터베이스 오브젝트에 인가된 CDMDB 계정을 식별하기 위해 시스템 문서를 검토한다. 만일 CDMDB 데이터베이스 소유권 목록이 존재하지 않거나 갱신할 필요가 있다면, 조치가 필요하다. 다음 쿼리가 이런 판단에 사용될 수 있다: “;with objects_cte as (SELECT o.name, o.type_desc, CASE WHEN o.principal_id is null then s.principal_id ELSE o.principal_id END as principal_id FROM sys.objects o INNER JOIN sys.schemas s  ON o.schema_id = s.schema_id WHERE o.is_ms_shipped = 0);, SELECT cte.name, cte.type_desc, dp.name as ObjectOwner FROM objects_cte cte INNER JOIN sys.database_principals dp ON cte.principal_id = dp.principal_id ORDER BY dp.name, cte.name;”. 만일 리스트 된 소유자가 인가 받지 않았다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT o.name, o.type_desc, CASE WHEN o.principal_id is null then s.principal_id ELSE o.principal_id END as principal_id FROM sys.objects o INNER JOIN sys.schemas s  ON o.schema_id = s.schema_id WHERE o.is_ms_shipped = 0);",
      "SELECT cte.name, cte.type_desc, dp.name as ObjectOwner FROM objects_cte cte INNER JOIN sys.database_principals dp ON cte.principal_id = dp.principal_id ORDER BY dp.name, cte.name;"
    ],
    "Fix": "오브젝트 소유권이 인가된 계정을 포함하여 시스템 문서를 추가/갱신하고, 인가 받지 않은 계정은 삭제한다. CDMDB에서 데이터베이스 오브젝트를 소유한 스키마를 변경하기 위해, 다음 코드를 예제로 사용한다: “USE AdventureWorks2012; GO ALTER SCHEMA HumanResources TRANSFER Person.Address; GO”. 주의: 코드를 파손할 수 있다. 이 해결안은 이런 코드의 교정과 함께 구현해야 한다. 실전에 적용하기 전에 테스트 해야 한다. 스케줄된 유지보수 기간에 적용한다.",
    "Fix_sql": [
      "USE AdventureWorks2012;",
      "GO ALTER SCHEMA HumanResources TRANSFER Person.Address;",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79081",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "데이터베이스 구조를 변경(제한되지는 않지만 테이블, 인덱스, 스토리지 등)하는데 사용되는 역할/그룹 및 로직 모듈(스토어드 프로시저, 함수, 트리거, CDMDB 외부 소프트웨어 링크)은 인가된 사용자로 제한되어야 한다.",
    "Check": "서버 문서로부터 데이터베이스 구조와 로직 모듈을 변경하도록 인가 받은 사용자/역할 목록을 입수한다. 다음 쿼리를 실행한다: “SELECT P.type_desc AS principal_type, P.name AS principal_name, O.type_desc, CASE class WHEN 0 THEN DB_NAME() WHEN 1 THEN OBJECT_SCHEMA_NAME(major_id) + '.' + OBJECT_NAME(major_id) WHEN 3 THEN SCHEMA_NAME(major_id) ELSE class_desc + '(' + CAST(major_id AS nvarchar) + ')' END AS securable_name, DP.state_desc, DP.permission_name FROM sys.database_permissions DP JOIN sys.database_principals P ON DP.grantee_principal_id = P.principal_id LEFT OUTER JOIN sys.all_objects O ON O.object_id = DP.major_id AND O.type IN ('TR','TA','P','X','RF','PC','IF','FN','TF','U') WHERE DP.type IN ('AL','ALTG') AND DP.class IN (0, 1, 53);, SELECT R.name AS role_name, M.type_desc AS principal_type, M.name AS principal_name FROM sys.database_principals R JOIN sys.database_role_members DRM ON R.principal_id = DRM.role_principal_id JOIN sys.database_principals M ON DRM.member_principal_id = M.principal_id WHERE R.name IN ('db_ddladmin','db_owner') AND M.name != 'dbo';”. 만일 리턴된 사용자/역할 허가가 명시된 오브젝트/유형을 변경하도록 인가 받지 않았다면, 조치가 필요하다. 만일 사용자/역할 멤버십을 인가 받지 않았다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT P.type_desc AS principal_type, P.name AS principal_name, O.type_desc, CASE class WHEN 0 THEN DB_NAME() WHEN 1 THEN OBJECT_SCHEMA_NAME(major_id) + '.' + OBJECT_NAME(major_id) WHEN 3 THEN SCHEMA_NAME(major_id) ELSE class_desc + '(' + CAST(major_id AS nvarchar) + ')' END AS securable_name, DP.state_desc, DP.permission_name FROM sys.database_permissions DP JOIN sys.database_principals P ON DP.grantee_principal_id = P.principal_id LEFT OUTER JOIN sys.all_objects O ON O.object_id = DP.major_id AND O.type IN ('TR','TA','P','X','RF','PC','IF','FN','TF','U') WHERE DP.type IN ('AL','ALTG') AND DP.class IN (0, 1, 53);",
      "SELECT R.name AS role_name, M.type_desc AS principal_type, M.name AS principal_name FROM sys.database_principals R JOIN sys.database_role_members DRM ON R.principal_id = DRM.role_principal_id JOIN sys.database_principals M ON DRM.member_principal_id = M.principal_id WHERE R.name IN ('db_ddladmin','db_owner') AND M.name != 'dbo';"
    ],
    "Fix": "데이터베이스 구조 및 로직 모듈을 변경하는 능력이 필요한 비-관리자 사용자의 승인을 입수하고 문서화 한다. ”REVOKE ALTER ON [<Object Name>] TO [<Principal Name>];”.",
    "Fix_sql": [
      "REVOKE ALTER ON [<Object Name>] TO [<Principal Name>];"
    ]
  },
  {
    "Id": "CDMV-79083",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "시스템 실패, 하드웨어 손실이나 디스크 장애 시에, CDMDB는 임무 프로세스에 최소 간섭으로 필요 데이터베이스를 복구할 수 있어야 한다.",
    "Check": "데이터베이스가 정적인지, 적절한 복구 모델이 사용되는지, 백업이 스케줄 되는지 및 데이터베이스 복구 계획이 수립되었는지 여부를 판단하기 위해 시스템보안계획(SSP)를 검토한다. 만일 SSP에서 데이터베이스가 정적이라고 서술하지 않았다면, 정적이 아니라고 간주한다. 만일 다른 정보가 존재하지 않는다면, 조치가 필요하다. 만일 데이터베이스가 정적이 아니고, 문서화된 복구 모델이 Bulk Logged이지만 이런 근거와 인가가 문서화되지 않았다면, 조치가 필요하다. 복구 모델을 판단하기 위해 다음을 실행한다: “USE [master] GO SELECT name, recovery_model_desc FROM sys.databases ORDER BY name;”. 만일 복구 모델 설명이 문서화된 복구 모델과 일치하지 않는다면, 조치가 필요하다. 백업 계획을 구현하는 설정 작업을 검토한다. 만일 존재하지 않는다면, 조치가 필요하다. 다음 쿼리를 실행하여 백업 이력을 점검한다. 데이터베이스의 최신 30일 백업을 점검한다: “USE [msdb] GO SELECT database_name, CASE type WHEN 'D' THEN 'Full' WHEN 'I' THEN 'Differential' WHEN 'L' THEN 'Log' ELSE type END AS backup_type, is_copy_only, backup_start_date, backup_finish_date FROM dbo.backupset WHERE backup_start_date >= dateadd(day, - 30, getdate()) ORDER BY database_name, backup_start_date DESC;”. 만일 이력 사항이 백업의 누락이나 차이에 의한 작업 실패 패턴을 표시한다면, 조치가 필요하다. 데이터베이스 복구가 매년이나 더 자주 테스트 된다는 증거와 가장 최근 테스트가 성공적이라는 증거를 검토한다. 만일 그렇지 않다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name, recovery_model_desc FROM sys.databases ORDER BY name;",
      "SELECT database_name, CASE type WHEN 'D' THEN 'Full' WHEN 'I' THEN 'Differential' WHEN 'L' THEN 'Log' ELSE type END AS backup_type, is_copy_only, backup_start_date, backup_finish_date FROM dbo.backupset WHERE backup_start_date >= dateadd(day, - 30, getdate()) ORDER BY database_name, backup_start_date DESC;"
    ],
    "Fix": "데이터베이스가 정적인지, 적절한 복구 모델이 사용되는지, 백업이 스케줄 되는지 및 데이터베이스 복구 계획이 수립되었는지 여부를 포함하여 시스템보안계획(SSP)을 변경한다. SSMS Object Explorer에서, 데이터베이스 이름을 오른쪽-클릭 >> “Properties”를 선택 >> “Options” 페이지 선택 >> 페이지 상단의 “Recovery Model” 필드 설정을 적절한 값으로 설정한다. SSMS Object Explorer에서,  >> “SQL Server Agent” >> “Jobs”로 확장한다. 백업 스케줄을 구현하기 위한 작업을 생성/변경/삭제한다. 다른 방법으로, T-SQL 코드나 제3자 백업 소프트웨어를 사용하여 수행할 수도 있다. 백업 실패를 유발하는 문제를 교정한다. 데이터베이스 복구는 최소 매년 테스트하여, 실패 유발 문제를 교정하고, 이런 테스트 기록을 유지 관리 한다. ",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79085",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB 데이터베이스 마스터 키 암호 패스워드는 KISA 패스워드 복잡성 요구사항을 만족해야 한다.",
    "Check": "다음 쿼리를 실행한다: “SELECT name FROM [master].sys.databases WHERE state = 0;”. 각 데이터베이스에 반복한다: “USE [database name] SELECT COUNT(name) FROM sys.symmetric_keys s, sys.key_encryptions k WHERE s.name = '##MS_DatabaseMasterKey##' AND s.symmetric_key_id = k.key_id AND k.crypt_type = 'ESKP';”. 만일 리턴값이 “0”보다 크다면, 데이터베이스 마스터 키가 존재하고 패스워드로 암호화 되었다. 데이터베이스 마스터 키를 암호화하는데 사용되는 패스워드 요구사항 절차/증거를 검토한다. 만일 패스워드가 KISA 패스워드 표준(최소 대문자 1자, 소문자 1자, 특수 문자 1자, 숫자 1자를 가진 최소 15자 문자 및 이전 패스워드와 최소 8자 변경)을 맞출 필요가 없다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name FROM [master].sys.databases WHERE state = 0;",
      "USE [database name] SELECT COUNT(name) FROM sys.symmetric_keys s, sys.key_encryptions k WHERE s.name = '##MS_DatabaseMasterKey##' AND s.symmetric_key_id = k.key_id AND k.crypt_type = 'ESKP';"
    ],
    "Fix": "최소 대문자 1자, 소문자 1자, 특수 문자 1자, 숫자 1자를 가진 최소 15자 문자 및 이전 패스워드와 최소 8자 변경 요구사항을 준수하고, 데이터베이스 마스터 키에 암호 패스워드를 배정한다. 데이터베이스 마스터 키 암호 패스워드를 변경하려면: “USE [database name];  ALTER MASTER KEY REGENERATE WITH ENCRYPTION BY PASSWORD = '[new password]';”. 주: 데이터베이스 마스터 키 암호 방법은 영향을 정밀하게 검토하지 않는 한 변경되면 안 된다. 마스터 키 암호를 변경하면 데이터베이스 마스터 키를 사용하는 모든 암호가 복호화되고 재-암호화 되어야 한다. 업무 실행 시간에는 작업하지 못한다. 상세한 정보는 MS SQL Server 문서를 참조하기 바란다.",
    "Fix_sql": [
      "USE [database name];",
      "ALTER MASTER KEY REGENERATE WITH ENCRYPTION BY PASSWORD = '[new password]';"
    ]
  },
  {
    "Id": "CDMV-79087",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "데이터베이스 마스터 키가 필요하고, 다른 암호 방법이 명시되지 않을 경우, 데이터베이스 마스터 키는 서비스 마스터 키로 암호화되어야 한다.",
    "Check": "만일 데이터베이스가 암호를 필요로 하지 않는다면, 조치가 필요하지 않다. 다음 쿼리를 실행한다: “SELECT name FROM [master].sys.databases WHERE is_master_key_encrypted_by_server = 1 AND owner_sid <> 1 AND state = 0;”. 주: 이 쿼리는 [sa] 계정이 애플리케이션 데이터베이스 소유자로 사용되지 않는다고 간주한다. 그렇지 않다면, 쿼리를 맞게 수정한다. 만일 데이터베이스가 쿼리로 리턴되지 않는다면, 조치가 필요하지 않다. 데이터베이스가 리턴 된다면, 서비스 마스터 키를 사용하는 데이터베이스 마스터 키 암호화가 인정되고 정보 소유자로부터 승인 받았으며, 암호화된 데이터가 DBA 접근을 탐지/제지하는 추가 보호를 필요로 하지 않는지 시스템보안계획(SSP)을 검증한다. 만일 승인되지 않는 한, 조치가 필요하다. 만일 승인된 추가 보호가 필요하다면, 추가 요구사항이 시스템보안계획(SSP)에 따라 적절하게 준비되었는지 검증한다. 경보나 다른 자동 모니터링과 함께 데이터베이스 마스터 키 접근 시의 추가 감사를 포함할 수도 있다. 만일 추가 요구사항이 적절하게 준비되지 않았다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name FROM [master].sys.databases WHERE is_master_key_encrypted_by_server = 1 AND owner_sid <> 1 AND state = 0;"
    ],
    "Fix": "가능하다면, 애플리케이션 관리자에게만 알려진 패스워드로 데이터베이스 마스터 키를 암호화 한다. 불가능하다면, 기밀 데이터를 보도록 인가 받지 않은 사용자가 데이터베이스 마스터 키를 접근하는지 탐지하는 추가 감사 이벤트나 경보를 구성한다. ",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79089",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "암호화에 사용되는 인증서는 백업되고 오프라인과 외부에 저장되어야 한다.",
    "Check": "만일 애플리케이션 소유자와 인가 담당자가 휴지기 데이터의 암호가 필요하지 않다면, 조치가 필요하지 않다. 시스템보안계획(SSP)에서 암호화에 사용되는 인증서 백업 증거와 절차를 검토한다. 만일 절차나 증거가 존재하지 않는다면, 조치가 필요하다. 만일 절차가 암호화에 사용되는 인증서의 오프라인이나 외부 스토리지를 보여주지 못한다면, 조치가 필요하다. 만일 절차가 인증서 백업의 접근 제한을 보여주지 못한다면, 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "암호화에 사용되는 인증서의 안전한 백업/저장을 위한 절차를 구현하고 문서화 한다. 인증서의 주의 깊고 제한된 접근/복구 및 백업/저자의 증거를 설정하는 절차 방법을 포함한다. 또한 외부 백업을 저장하는 규정을 포함한다. “BACKUP CERTIFICATE 'CertificateName' TO FILE = 'path_to_file' WITH PRIVATE KEY (FILE = 'path_to_pvk', ENCRYPTION BY PASSWORD = 'password');”. 패스워드가 필요하기 때문에, 평문으로 저장되거나 인가 받지 않은 사람에게 노출되지 않도록 주의한다. ",
    "Fix_sql": [
      "BACKUP CERTIFICATE 'CertificateName' TO FILE = 'path_to_file' WITH PRIVATE KEY (FILE = 'path_to_pvk', ENCRYPTION BY PASSWORD = 'password');"
    ]
  },
  {
    "Id": "CDMV-79091",
    "Risk": "L",
    "Status": "Ready",
    "Subject": "CDMDB는 비-보안 기능과 보안 기능을 분리해야 한다.",
    "Check": "CDMDB 내부에 관리되는 보안 기능(허가 목록, 추가 인증 정보, 스토어드 프로시저, 애플리케이션 특정 감사 등)의 구성 항목을 판단한다. 구성 항목이 발견되면, 보안 기능을 구현하는 이런 오브젝트/코드가 보안 기능을 위해 명확하게 생성된 별개 데이터베이스/스키마/테이블 같은 별개 보안 도메인에 위치하는지 판단하기 위해 CDMDB를 점검한다. 모든 사용자-정의 데이터베이스를 리스트 하기 위해 다음 쿼리를 실행한다: “SELECT Name FROM sys.databases WHERE database_id > 4 ORDER BY 1;”. 어느 곳에 보안 관련 기능을 저장할 지 판단하기 위해 데이터베이스 구조를 검토한다. 만일 보안-관련 데이터베이스 오브젝트/코드가 별개로 유지되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT Name FROM sys.databases WHERE database_id > 4 ORDER BY 1;"
    ],
    "Fix": "애플리케이션 로직을 구현하는 데이터베이스 오브젝트/코드와 별개 보안 도메인, 별개 데이터베이스/스키마/테이블에 보안-관련 데이터베이스가 위치하는지 서버 문서를 점검한다. MS SQL Server 2005부터 데이터베이스 오브젝트 스키마 개념을 도입하였다. 스키마는 데이터베이스 오브젝트를 저장하는데 사용되는 별개 네임스페이스/컨테이너와 유사하다. 보안 허가가 스키마에 적용되어, 접근 권한을 기반으로 데이터베이스 오브젝트를 분리하고 보호하는 중요한 툴이다. 스키마는 데이터베이스 보안-관련 관리에 필요한 작업을 줄여주고, 유연성을 증대한다. 사용자-스키마 분리를 통하여, 데이터베이스 오브젝트 허가 관리에 더 많은 유연성을 가질 수 있다. 스키마는 데이터베이스 오브젝트의 네임드 컨테이너로, 별개 네임스페이스로 오브젝트를 그룹화 할 수 있다. 가능하다면, 애플리케이션 로직을 구현하는 데이터베이스 오브젝트/코드와 별개 데이터베이스/스키마나 다른 별개 보안 도메인에 보안-관련 데이터베이스 오브젝트를 위치시킨다. 모든 경우에, 효율적인 격리를 제공하기 위해 서버-수준/데이터베이스-수준 보안-관련 오브젝트에 허가를 추가/삭제하기 위해 GRANT, REVOKE, DENY, ALTER ROLE ... , ADD MEMBER ...  및 ALTER ROLE ... , DROP MEMBER를 사용한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79093",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB 데이터베이스 컨텐트는 데이터-전송 정책 강화에 의해 비인가/비의도 정보 전송으로부터 보호되어야 한다.",
    "Check": "실행 시스템에서 개발/테스트 데이터를 지우는 절차를 검토한다. 실행 시스템 데이터의 개발/테스트 시스템이나 다른 목적의 위치로 이동을 위한 스크립트/코드를 검토한다. 실행 시스템 데이터의 복제가본이 보호되지 않은 위치에 잔존하지 않는지 검증한다. 만일 데이터 이동에 사용된 코드가 조직-정의 데이터 전송 정책을 준수하지 않거나, 보호되지 않은 위치의 실행 시스템 데이터의 복제본을 제거하지 못한다면, 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "실행 시스템에서 개발/테스트 시스템으로 데이터를 이동하는데 사용되는 코드가 조직-정의 데이터 전송 정책을 준수하고, 실행 시스템 데이터의 복제본이 안전하지 않은 위치에 잔존하지 않도록 코드를 변경한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79095",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 조직이 명확하게 식별한 모든 데이터 입력 예외사항의 타당성을 점검해야 한다.",
    "Check": "데이터베이스가 부정당한 입력으로부터 보호되는지 여부를 판단하기 위해 DBMS 코드(스토어드 프로시저, 함수, 트리거), 애플리케이션 코드, 설정, 컬럼/필드 정의 및 제약사항을 검토한다.  만일 데이터베이스에 입력이나 작동하는 부정당한 데이터를 허용하는 코드가 존재한다면, 조치가 필요하다. 만일 컬럼/필드 정의가 데이터 속성을 반영하지 않았다면, 조치가 필요하다. 만일 컬럼/필드가 필요 시에 제한 사항이나 타당성 검증을 가지고 있지 않다면, 조치가 필요하다. 컬럼/필드가 이름/문맥에서 강력한 형식과 제한 사항을 가지더라도, 어쩔 수 없이 자유-형식을 가지고 시스템 문서에 언급된다면, 보호 대책의 부재는 조치가 필요하지 않다. 컬럼/필드가 이름, 표제, 코멘트, 설명, 텍스트 등으로 명확하게 식별된다면, 보호 대책의 부재는 조치가 필요하지 않다.",
    "Check_sql": null,
    "Fix": "데이터 입력을 검증하기 위해 파라미터화 된 쿼리, 제한, 포린-키 등을 사용한다. 데이터베이스에서 요구되는 데로 정확한 컬럼 데이터 유형을 적절하게 사용하기 위해 CDM DB를 변경한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79097",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 비-특권 사용자에게 공격자가 악용할 수 있는 정보를 누출하지 않고 교정 활동에 필요한 정보를 제공하는 에러 메시지를 제공해야 한다.",
    "Check": "에러 메시지가 일반 사용자에게 문제를 설명하기 위해 필요한 범위를 벗어난 정보를 가졌는지 여부를 판단하기 위해, 애플리케이션 행태와 사용자-정의 데이터베이스 코드(스토어드 프로시저, 트리거)를 검토한다. 만일 데이터베이스 에러 메시지가 호스트 시스템이나 데이터베이스 구조를 식별하는데 유용한 정보, 개인식별정보(PII) 데이터 및 기밀 업무 데이터를 가진다면, 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "최종사용자에게 에러를 설명하는데 필요하지 않은 정보를 제거하기 위해 데이터베이스 코드를 조정한다. 비-관리자 사용자에게 리턴되는 특정 시스템-수준 에러 정보를 표시하기 위해 트레이스 플래그 3625의 활성화를 검토한다. SSCM 기동 >> SQL Services 클릭 >> Database “Properties” 오픈 >> “Service Parameters” 탭 클릭 >> “-T3625” 입력 >> “Add” 클릭 >> “OK” 클릭 >> 데이터베이스 재시작",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79099",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 조직-정의 보안 라벨 값을 가진 보안 라벨의 조직-정의 유형을 저장-중 정보와 연계시켜야 한다.",
    "Check": "만일 보안 라벨링이 필요하지 않다면, 조치가 필요하지 않다. 만일 보안 라벨링 요구사항이 명시되었지만, 제3자 솔루션이나 SQL Server Row-수준 보안 솔루션이 저장-중 정보에 라벨을 신뢰성 있게 유지 관리하도록 구현되지 않았다면, 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "저장-중 정보의 안전한 보안 라벨링을 제공하기 위해 SQL Server Row-수준 보안이나 제3자 소프트웨어를 구현하거나, 사용자-정의 데이터베이스 구조, 데이터 항목 및 애플리케이션 코드를 추가한다. “https://msdn.MS.com/en-us/library/dn765131.aspx”을 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79101",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 조직-정의 보안 라벨 값을 가진 보안 라벨의 조직-정의 유형을 처리-중 정보와 연계시켜야 한다.",
    "Check": "만일 보안 라벨링이 필요하지 않다면, 조치가 필요하지 않다. 만일 보안 라벨링 요구사항이 명시되었지만, 제3자 솔루션이나 SQL Server Row-수준 보안 솔루션이 처리-중 정보에 라벨을 신뢰성 있게 유지 관리하도록 구현되지 않았다면, 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "처리-중 정보의 안전한 보안 라벨링을 제공하기 위해 SQL Server Row-수준 보안이나 제3자 소프트웨어를 구현하거나, 사용자-정의 데이터베이스 구조, 데이터 항목 및 애플리케이션 코드를 추가한다. “https://msdn.MS.com/en-us/library/dn765131.aspx”을 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79103",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 조직-정의 보안 라벨 값을 가진 보안 라벨의 조직-정의 유형을 전송-중 정보와 연계시켜야 한다.",
    "Check": "만일 보안 라벨링이 필요하지 않다면, 조치가 필요하지 않다. 만일 보안 라벨링 요구사항이 명시되었지만, 제3자 솔루션이나 SQL Server Row-수준 보안 솔루션이 전송-중 정보에 라벨을 신뢰성 있게 유지 관리하도록 구현되지 않았다면, 조치가 필요하다. ",
    "Check_sql": null,
    "Fix": "전송-중 정보의 안전한 보안 라벨링을 제공하기 위해 SQL Server Row-수준 보안이나 제3자 소프트웨어를 구현하거나, 사용자-정의 데이터베이스 구조, 데이터 항목 및 애플리케이션 코드를 추가한다. “https://msdn.MS.com/en-us/library/dn765131.aspx”을 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79105",
    "Risk": "L",
    "Status": "Ready",
    "Subject": "CDMDB는 정의된 주체/객체에 데이터 소유자가 정의한 데로 임의적 접근 통제 정책을 강제해야 한다.",
    "Check": "오브젝트 소유권 및 인가 위임을 위한 요구사항을 판단하기 위해 시스템 문서를 검토한다. 데이터베이스 오브젝트 소유권을 찾기 위해 다음 쿼리를 사용한다: 스키마나 dbo가 소유하지 않은 스키마: “SELECT name AS schema_name, USER_NAME(principal_id) AS schema_owner FROM sys.schemas WHERE schema_id != principal_id AND principal_id != 1;”. 개별 보안-주체가 소유한 오브젝트: “SELECT object_id, name AS securable, USER_NAME(principal_id) AS object_owner, type_desc FROM sys.objects WHERE is_ms_shipped = 0 AND principal_id IS NOT NULL ORDER BY type_desc, securable, object_owner;”. 추가 허가를 배정하는 권한을 위임한 데이터베이스 사용자를 찾기 위해 다음 쿼리를 사용한다: “SELECT U.type_desc, U.name AS grantee, DP.class_desc AS securable_type, CASE DP.class WHEN 0 THEN DB_NAME() WHEN 1 THEN OBJECT_NAME(DP.major_id) WHEN 3 THEN SCHEMA_NAME(DP.major_id) ELSE CAST(DP.major_id AS nvarchar) END AS securable, permission_name, state_desc FROM sys.database_permissions DP JOIN sys.database_principals U ON DP.grantee_principal_id = U.principal_id WHERE DP.state = 'W' ORDER BY grantee, securable_type, securable;”. 만일 이런 권한이 문서화되지 않거나 인가 받지 않았다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS schema_name, USER_NAME(principal_id) AS schema_owner FROM sys.schemas WHERE schema_id != principal_id AND principal_id != 1;",
      "SELECT object_id, name AS securable, USER_NAME(principal_id) AS object_owner, type_desc FROM sys.objects WHERE is_ms_shipped = 0 AND principal_id IS NOT NULL ORDER BY type_desc, securable, object_owner;",
      "SELECT U.type_desc, U.name AS grantee, DP.class_desc AS securable_type, CASE DP.class WHEN 0 THEN DB_NAME() WHEN 1 THEN OBJECT_NAME(DP.major_id) WHEN 3 THEN SCHEMA_NAME(DP.major_id) ELSE CAST(DP.major_id AS nvarchar) END AS securable, permission_name, state_desc FROM sys.database_permissions DP JOIN sys.database_principals U ON DP.grantee_principal_id = U.principal_id WHERE DP.state = 'W' ORDER BY grantee, securable_type, securable;"
    ],
    "Fix": "오브젝트 소유권을 교정하기 위해 다음 쿼리를 사용한다: “ALTER AUTHORIZATION ON <Securable> TO <Principal>;”. 인가 받지 않은 허가를 철회하기 위해 다음 쿼리를 사용한다: “REVOKE [Permission] ON <Securable> TO <Principal>;”.",
    "Fix_sql": [
      "ALTER AUTHORIZATION ON <Securable> TO <Principal>;",
      "REVOKE [Permission] ON <Securable> TO <Principal>;"
    ]
  },
  {
    "Id": "CDMV-79107",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "“EXECUTE AS”를 이용하는 스토어드 프로시저와 함수 실행은 필요한 경우에만 허용되어야 한다.",
    "Check": "“EXECUTE AS”를 이용하는 스토어드 프로시저와 함수 목록을 입수하기 위해 시스템 문서를 검토한다. 다음 쿼리를 실행한다: “SELECT S.name AS schema_name, O.name AS module_name, USER_NAME ( CASE .execute_as_principal_id WHEN -2 THEN COALESCE(O.principal_id, S.principal_id) ELSE M.execute_as_principal_id END ) AS execute_as FROM sys.sql_modules M JOIN sys.objects O ON M.object_id = O.object_id JOIN sys.schemas S ON O.schema_id = S.schema_id WHERE execute_as_principal_id IS NOT NULL ORDER BY schema_name, module_name;”. 만일 프로시저나 문서화되지 않은 프로시저나 함수가 리턴 된다면, 조치가 필요하다.",
    "Check_sql": [
      "EXECUTE AS;",
      "SELECT S.name AS schema_name, O.name AS module_name, USER_NAME ( CASE .execute_as_principal_id WHEN -2 THEN COALESCE(O.principal_id, S.principal_id) ELSE M.execute_as_principal_id END ) AS execute_as FROM sys.sql_modules M JOIN sys.objects O ON M.object_id = O.object_id JOIN sys.schemas S ON O.schema_id = S.schema_id WHERE execute_as_principal_id IS NOT NULL ORDER BY schema_name, module_name;"
    ],
    "Fix": "“EXECUTE AS” 구문을 제거하기 위해 스토어드 프로시저와 함수를 변경한다.",
    "Fix_sql": [
      "EXECUTE AS;"
    ]
  },
  {
    "Id": "CDMV-79109",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 명확한 특권 상태 없는 로직 모듈(스토어드 프로시저, 함수, 트리거, 뷰 등)의 사용자 설치를 금지해야 한다.",
    "Check": "만일 CDMDB가 소프트웨어 개발, 실험 및 개발-수준 테스트(즉, 실행 시스템, 통합 테스트, 부하 테스트 및 사용자 인수 테스트는 제외) 만을 지원한다면, 조치가 필요하지 않다. 서버 문서에서 로직 모듈을 생성/변경/대체하도록 인가된 사용자/역할의 목록을 입수한다. 각 사용자 데이터베이스에서 다음 쿼리를 실행한다: “SELECT P.type_desc AS principal_type, P.name AS principal_name, O.type_desc, CASE class WHEN 0 THEN DB_NAME() WHEN 1 THEN OBJECT_SCHEMA_NAME(major_id) + '.' + OBJECT_NAME(major_id) WHEN 3 THEN SCHEMA_NAME(major_id) ELSE class_desc + '(' + CAST(major_id AS nvarchar) + ')' END AS securable_name, DP.state_desc, DP.permission_name FROM sys.database_permissions DP JOIN sys.database_principals P ON DP.grantee_principal_id = P.principal_id LEFT OUTER JOIN sys.all_objects O ON O.object_id = DP.major_id AND O.type IN ('TR','TA','P','X','RF','PC','IF','FN','TF','U') WHERE DP.type IN ('AL','ALTG') AND DP.class IN (0, 1, 53);, SELECT R.name AS role_name, M.type_desc AS principal_type, M.name AS principal_name FROM sys.database_principals R JOIN sys.database_role_members DRM ON R.principal_id = DRM.role_principal_id JOIN sys.database_principals M ON DRM.member_principal_id = M.principal_id WHERE R.name IN ('db ddladmin','db_owner') AND M.name != 'dbo';”. 만일 리턴된 사용자/역할이 명시된 오브젝트/유형을 변경하도록 인가 받지 않았다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT P.type_desc AS principal_type, P.name AS principal_name, O.type_desc, CASE class WHEN 0 THEN DB_NAME() WHEN 1 THEN OBJECT_SCHEMA_NAME(major_id) + '.' + OBJECT_NAME(major_id) WHEN 3 THEN SCHEMA_NAME(major_id) ELSE class_desc + '(' + CAST(major_id AS nvarchar) + ')' END AS securable_name, DP.state_desc, DP.permission_name FROM sys.database_permissions DP JOIN sys.database_principals P ON DP.grantee_principal_id = P.principal_id LEFT OUTER JOIN sys.all_objects O ON O.object_id = DP.major_id AND O.type IN ('TR','TA','P','X','RF','PC','IF','FN','TF','U') WHERE DP.type IN ('AL','ALTG') AND DP.class IN (0, 1, 53);",
      "SELECT R.name AS role_name, M.type_desc AS principal_type, M.name AS principal_name FROM sys.database_principals R JOIN sys.database_role_members DRM ON R.principal_id = DRM.role_principal_id JOIN sys.database_principals M ON DRM.member_principal_id = M.principal_id WHERE R.name IN ('db ddladmin','db_owner') AND M.name != 'dbo';"
    ],
    "Fix": "로직 모듈을 생성/변경/대체하는 능력이 필요한 비-관리자 사용자의 승인을 입수하고 문서화 한다. 다음 쿼리로 인가 받지 않은 사용자/역할의 인가를 변경 철회한다: “REVOKE ALTER ON [<Object Name>] TO [<Principal Name>];”.",
    "Fix_sql": [
      "REVOKE ALTER ON [<Object Name>] TO [<Principal Name>];"
    ]
  },
  {
    "Id": "CDMV-79111",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 데이터베이스 구성 변경과 관련된 접근 제한(비인가 사용자)을 강제해야 한다.",
    "Check": "CDMDB 데이터베이스의 특권 역할을 가진 사용자 목록을 입수한다. 사용자/역할 및 해당 역할 멤버십 목록을 입수하기 위해 다음 쿼리를 실행한다: “SELECT p.name AS Principal, p.type_desc AS Type,   r.name AS Role FROM sys.database_principals p INNER JOIN sys.database_role_members rm ON p.principal_id = rm.member_principal_id INNER JOIN sys.database_principals r ON rm.role_principal_id = r.principal_id WHERE r.name = 'db_owner' UNION ALL SELECT l.name AS Principal, l.type_desc AS Type,  'dbo' AS Role FROM sys.databases d INNER JOIN sys.server_principals l ON d.owner_sid = l.sid WHERE d.name = DB_NAME();”. 리턴된 사용자/역할이 인가 받았는지 검증하기 위해 서버 문서를 검토한다. 만일 사용자/역할이 문서화 되지 않고 인가 받지 않았다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT p.name AS Principal, p.type_desc AS Type,   r.name AS Role FROM sys.database_principals p INNER JOIN sys.database_role_members rm ON p.principal_id = rm.member_principal_id INNER JOIN sys.database_principals r ON rm.role_principal_id = r.principal_id WHERE r.name = 'db_owner' UNION ALL SELECT l.name AS Principal, l.type_desc AS Type,  'dbo' AS Role FROM sys.databases d INNER JOIN sys.server_principals l ON d.owner_sid = l.sid WHERE d.name = DB_NAME();"
    ],
    "Fix": "역할로부터 인가 받지 않은 사용자를 삭제한다: “ALTER ROLE DROP MEMBER user;”. “https://msdn.MS.com/en-us/library/ms189775.aspx”를 참조하기 바란다. 인가된 로그인에 데이터베이스 사용자를 설정한다: “ALTER AUTHORIZATION ON database::DatabaseName TO login;”. “https://msdn.MS.com/en-us/library/ms187359.aspx”를 참조하기 바란다.",
    "Fix_sql": [
      "ALTER ROLE DROP MEMBER user;",
      "ALTER AUTHORIZATION ON database::DatabaseName TO login;"
    ]
  },
  {
    "Id": "CDMV-79113",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 데이터 소유자 요구사항에 따라 기밀분류 정보를 보호하기 위해 KISA-승인 암호법을 사용해야 한다.",
    "Check": "기밀분류나 민감한 정보의 암호법이 정보 소유자에 의해 요구되는지 여부를 판단하기 위해 시스템 문서를 검토한다. 만일 시스템 문서가 CDMDB에서 관리되는 정보 유형(기밀분류, 민감, 비기밀분류)을 명시하지 않는다면, 조치가 필요하다. 만일 기밀분류나 민감 정보가 CDMDB 데이터베이스나 구성에 존재하지 않는다면, 조치가 필요하지 않다. ",
    "Check_sql": null,
    "Fix": "KISA-승인 암호 준수 알고리즘을 사용하기 위해 암호 기능을 구성한다. ",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79115",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 조직-정의 정보시스템 컴포넌트의 조직-정의 휴지기 정보(최소 개인식별정보 및 기밀분류 정보 포함)의 비인가 변경을 방지하는 암호화 메커니즘을 구현해야 한다.",
    "Check": "조직이 최소 개인식별정보 및 기밀분류 정보를 포함하여 변경으로부터 보호되어야 하는 휴지기 정보를 가졌는지 여부를 판단하기 위해 시스템 문서를 검토한다. 만일 정보가 이런 보호를 요구하지 않는다면, 조치가 필요하지 않다. CDMDB, Windows 및 관련된 추가 소프트웨어의 구성을 검토한다. 만일 전체-디스크 암호화가 필요하고, Windows나 스토리지 시스템이 이렇게 구성되지 않았다면, 조치가 필요하다. 만일 데이터베이스 “투명 데이터 암호화(TDE, Transparent Data Encryption)”가 요청된다면, 활성화되었는지 여부를 점검한다: “SELECT DB_NAME(database_id) AS [Database Name], CASE encryption_state WHEN 0 THEN 'No database encryption key present, no encryption' WHEN 1 THEN 'Unencrypted' WHEN 2 THEN 'Encryption in progress' WHEN 3 THEN 'Encrypted' WHEN 4 THEN 'Key change in progress' WHEN 5 THEN 'Decryption in progress' WHEN 6 THEN 'Protection change in progress' END AS [Encryption State] FROM sys.dm_database_encryption_keys;”. 각 사용자 데이터베이스에서, 어떤 암호화가 요청되었는데 비-암호화라면, 조치가 필요하다. 만일 데이터 소유자(조회할 수 있는)와 데이터 관리자(접근 권한이 없는) 간의 분리와 테이블/컬럼 암호화가 개인식별정보나 유사 유형 데이터에 필요하다면, “항상 암호화(Always Encrypted)”를 사용한다. 상세한 정보는 “https://msdn.MS.com/en-us/library/mt163865.aspx”를 참조하기 바란다. “항상 암호화(Always Encrypted)” 설정의 관련 테이블/컬럼의 정의와 내용을 검토한다. 만일 암호화 보호가 필요하다고 정의된 정보가 암호화되지 않았다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT DB_NAME(database_id) AS [Database Name], CASE encryption_state WHEN 0 THEN 'No database encryption key present, no encryption' WHEN 1 THEN 'Unencrypted' WHEN 2 THEN 'Encryption in progress' WHEN 3 THEN 'Encrypted' WHEN 4 THEN 'Key change in progress' WHEN 5 THEN 'Decryption in progress' WHEN 6 THEN 'Protection change in progress' END AS [Encryption State] FROM sys.dm_database_encryption_keys;"
    ],
    "Fix": "전체-디스크 암호화가 요청된다면, Windows와 스토리지 시스템이 제공되도록 구성한다. “투명 데이터 암호화(TDE, Transparent Data Encryption)”가 요청된다면, 마스터 키를 생성하고 마스터 키로 보호된 인증서를 입수하고, 데이터베이스 암호화 키를 생성하고 인증서로 보호하고 데이터베이스를 암호화 사용으로 설정한다. 상세한 정보는 “https://msdn.MS.com/en-us/library/bb934049.aspx”를 참조하기 바란다. 테이블/컬럼 암호화가 필요하다면, 해당 테이블/컬럼의 암호화를 활성화 한다. “항상 암호화(Always Encrypted)”에 관한 상세한 정보는 “https://msdn.MS.com/en-us/library/mt163865.aspx”를 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79117",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 조직-정의 정보시스템 컴포넌트의 조직-정의 휴지기 정보의 비인가 공개를 방지하는 암호화 메커니즘을 구현해야 한다. ",
    "Check": "조직이 최소 개인식별정보 및 기밀분류 정보를 포함하여 공개로부터 보호되어야 하는 휴지기 정보를 가졌는지 여부를 판단하기 위해 시스템 문서를 검토한다. 만일 정보가 이런 보호를 요구하지 않는다면, 조치가 필요하지 않다. 만일 전체-디스크 암호화가 필요하고, Windows나 스토리지 시스템이 이렇게 구성되지 않았다면, 조치가 필요하다. 만일 데이터베이스 “투명 데이터 암호화(TDE, Transparent Data Encryption)”가 요청된다면, 활성화되었는지 여부를 점검한다: “SELECT DB_NAME(database_id) AS [Database Name], CASE encryption_state WHEN 0 THEN 'No database encryption key present, no encryption' WHEN 1 THEN 'Unencrypted' WHEN 2 THEN 'Encryption in progress' WHEN 3 THEN 'Encrypted' WHEN 4 THEN 'Key change in progress' WHEN 5 THEN 'Decryption in progress' WHEN 6 THEN 'Protection change in progress' END AS [Encryption State] FROM sys.dm_database_encryption_keys;”. 각 사용자 데이터베이스에서, 어떤 암호화가 요청되었는데 비-암호화라면, 조치가 필요하다. 만일 데이터 소유자(조회할 수 있는)와 데이터 관리자(접근 권한이 없는) 간의 분리와 테이블/컬럼 암호화가 개인식별정보나 유사 유형 데이터에 필요하다면, “항상 암호화(Always Encrypted)”를 사용한다. 상세한 정보는 “https://msdn.MS.com/en-us/library/mt163865.aspx”를 참조하기 바란다. “항상 암호화(Always Encrypted)” 설정의 관련 테이블/컬럼의 정의와 내용을 검토한다. 만일 암호화 보호가 필요하다고 정의된 정보가 암호화되지 않았다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT DB_NAME(database_id) AS [Database Name], CASE encryption_state WHEN 0 THEN 'No database encryption key present, no encryption' WHEN 1 THEN 'Unencrypted' WHEN 2 THEN 'Encryption in progress' WHEN 3 THEN 'Encrypted' WHEN 4 THEN 'Key change in progress' WHEN 5 THEN 'Decryption in progress' WHEN 6 THEN 'Protection change in progress' END AS [Encryption State] FROM sys.dm_database_encryption_keys;"
    ],
    "Fix": "전체-디스크 암호화가 요청된다면, Windows와 스토리지 시스템이 제공되도록 구성한다. “투명 데이터 암호화(TDE, Transparent Data Encryption)”가 요청된다면, 마스터 키를 생성하고 마스터 키로 보호된 인증서를 입수하고, 데이터베이스 암호화 키를 생성하고 인증서로 보호하고 데이터베이스를 암호화 사용으로 설정한다. 상세한 정보는 “https://msdn.MS.com/en-us/library/bb934049.aspx”를 참조하기 바란다. 테이블/컬럼 암호화가 필요하다면, 해당 테이블/컬럼의 암호화를 활성화 한다. “항상 암호화(Always Encrypted)”에 관한 상세한 정보는 “https://msdn.MS.com/en-us/library/mt163865.aspx”를 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79119",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 모든 계정과 계정 유형에 대하여 사용자 별로 조직-정의 개수로 동시-사용 세션 개수를 제한해야 한다.",
    "Check": "제한이 정의되어 있는지 여부를 판단하기 위해 시스템 문서를 검토한다. 만일 그렇지 않다면, 데이터베이스 관리자 용으로 10개 제한, 모든 다른 사용자 용으로 2개로 가정한다. 만일 로그온 트리거와 다른 메커니즘이 사용된다면, 적절한 수단으로 교정 작업을 검증한다. 만일 정확하게 동작하지 않는다면, 조치가 필요하다. 그렇지 않다면, 로그온 트리거가 존재하는지 여부를 판단한다: SSMS Object Explorer >> [CDMDB] 확장 >> Security >> Server Objects >> Triggers를 확인하거나 다음 쿼리를 실행한다: “SELECT name FROM master.sys.server_triggers;”. 트리거가 리스트 되지 않는다면, 조치가 필요하다. 만일 트리거가 리스트 된다면, 사용자 별로 동시-사용 세션 개수를 제한하는 트리거를 식별한다. 만일 없다면, 조치가 필요하다. 만일 존재하지만 비활성화 되었다면, 조치가 필요하다. 논리적 교정과 문서화된 제한 중수를 위해 트리거 소스 코드를 확인한다. 만일 에러나 변형이 존재한다면, 조치가 필요하다. 시스템이 사용자 세션이 설정될 때마다 트리거를 실행하는지 검증한다. 만일 모든 유형의 사용자에 정확하게 동작하지 않는다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT name FROM master.sys.server_triggers;"
    ],
    "Fix": "CDMDB를 접근하는 사용자 계정의 유형에 맞게 제한 설정하고, 시스템 문서에 기록한다. 일반 사용자에게 동적 관리 뷰를 노출하지 않고 제한을 강제하기 위해 하나 이상의 로그온 트리거를 구현한다. “CREATE TRIGGER SQL_STIG_Connection_Limit ON ALL SERVER WITH EXECUTE AS 'sa';”. 디폴트 관리자 “sa”는 삭제해야 되므로 적절한 ID로 대체한다. “FOR LOGON AS BEGIN IF (SELECT COUNT(1) FROM sys.dm_exec_sessions         WHERE is_user_process = 1 And original_login_name = ORIGINAL_LOGIN() ) > 1000 --Organizationally defined number BEGIN PRINT 'The login [' + ORIGINAL_LOGIN() + '] has exceeded the concurrent session limit.' ROLLBACK; END END;”.  “https://msdn.MS.com/en-us/library/ms189799.aspx”를 참조하기 바란다.",
    "Fix_sql": [
      "CREATE TRIGGER SQL_STIG_Connection_Limit ON ALL SERVER WITH EXECUTE AS 'sa';",
      "FOR LOGON AS BEGIN IF (SELECT COUNT(1) FROM sys.dm_exec_sessions         WHERE is_user_process = 1 And original_login_name = ORIGINAL_LOGIN() ) > 1000 --Organizationally defined number BEGIN PRINT 'The login [' + ORIGINAL_LOGIN() + '] has exceeded the concurrent session limit.' ROLLBACK;"
    ]
  },
  {
    "Id": "CDMV-79121",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 모든 사용자/그룹/역할/보안-주체에 관해 계정 관리와 자동화를 제공하는 조직-정의 인증/접근 메커니즘과 통합해야 한다.",
    "Check": "CDMDB가 Windows 인증 만을 사용하도록 구성되었는지 여부를 판단한다. SSMS Object Explorer애서 CDMDB를 클릭 >> “Properties”를 선택 >> “Security”를 선택. 만약 Windows Authentication Mode가 선택되었다면, 조치가 필요하지 않다. SSMS Transact-SQL 편집기 같은 쿼리 인터페이스에서 다음 쿼리를 실행한다: “SELECT CASE SERVERPROPERTY('IsIntegratedSecurityOnly') WHEN 1 THEN 'Windows Authentication' WHEN 0 THEN 'Windows and SQL Server Authentication' END as [Authentication Mode];”. 만일 “Authentication Mode” 컬럼의 리턴 값이 “Windows Authentication”이면, 조치가 필요하지 않다. 혼합-모드(SQL Server 인증 및 Windows 인증)가 사용되고, 혼합-모드 사용이 문서화되고 승인되었다면, 조치가 필요하지 않다. 문서에서 CDMDB과 관리하도록 인가된 계정 목록을 입수한다. 계정(SQL 로그인)이 CDMDB에서 관리되는지 여부를 판단한다. 다음 쿼리를 실행한다: “SELECT name FROM sys.sql_logins WHERE type_desc = 'SQL_LOGIN' AND is_disabled = 0;”. 만일 쿼리가 리스트 한 계정이 문서에 없다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT CASE SERVERPROPERTY('IsIntegratedSecurityOnly') WHEN 1 THEN 'Windows Authentication' WHEN 0 THEN 'Windows and SQL Server Authentication' END as [Authentication Mode];",
      "SELECT name FROM sys.sql_logins WHERE type_desc = 'SQL_LOGIN' AND is_disabled = 0;"
    ],
    "Fix": "만일 혼합-모드가 필요하다면, 필요성과 근거를 문서화 한다. CDMDB 인증을 최소로 유지하는 대책을 서술하고, 패스워드를 보호하는 대책을 서술하며 사용된 SQL 로그인을 서술하고 관리자 승인을 받는다. 위험이 정보시스템보안담당자/정보시스템보안관리자(ISSO/ISSM)에 의해 승인되어야 한다. 만일 혼합 보드가 필요하지 않다면, 다음과 같이 비활성화 한다: SSMS Object Explorer >> 데이터베이스를 오른쪽-클릭 >> “Properties”를 선택 >> “Security” 페이지를 선택한다. Windows Authentication Mode의 라디오버튼을 선택하고 “OK”를 클릭한다. CDMDB를 다시 시작한다. 다음과 같은 구문을 실행한다: “USE [master] EXEC xp_instance_regwrite N'HKEY_LOCAL_MACHINE', N'Software\\MS\\MSSQLServer\\MSSQLServer', N'LoginMode', REG_DWORD, 2 GO”. CDMDB를 다시 시작한다. 각 계정이 CDMDB에서 관리되지만 필요하지 않을 경우, 사용자(SQL 로그인)를 삭제하거나 비활성화 한다. 필요에 따라 적절하게 구성된 계정으로 대체한다. SSMS Object Explorer에서 SQL 로그인을 삭제하거나 비활성화 하기 위해, “Security Logins” >> 로그인 이름 오른쪽-클릭 >> “Delete”나 “Disable”를 클릭. 쿼리로 SQL 로그인을 삭제하거나 비활성화 하려면, “USE master; DROP LOGIN login_name; ALTER LOGIN login_name DISABLE;”. 로그인을 삭제한다고 동등 데이터베이스 사용자를 삭제하지는 않는다. 로그인에 매핑된 사용자를 가진 하나 이상의 데이터베이스가 존재할 수도 있다. 필요하지 않다면 사용자를 삭제한다. SSMS Object Explorer에서 사용자를 삭제하려면, “Database >> Security Users >> 사용자 이름 클릭 >> “Delete” 클릭. 쿼리로 사용자를 삭제하려면, “USE database_name; DROP USER <user_name>;”.",
    "Fix_sql": [
      "USE [master] EXEC xp_instance_regwrite N'HKEY_LOCAL_MACHINE', N'Software\\MS\\MSSQLServer\\MSSQLServer', N'LoginMode', REG_DWORD, 2 GO;",
      "USE master;",
      "DROP LOGIN login_name;",
      "ALTER LOGIN login_name DISABLE;",
      "USE database_name;",
      "DROP USER <user_name>;"
    ]
  },
  {
    "Id": "CDMV-79123",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 가장 안전한 인증 방법을 사용하도록 구성되어야 한다.",
    "Check": "만일 CDMDB가 액티브 디렉터리 도메인이 아니라면, 조치가 적용 불가하다. CDMDB의 전체 주소 도메인 이름을 입수한다: Windows 탐색기 >> “컴퓨터”나 “내 PC” 오른쪽-클릭 >> “속성” 클릭. CDMDB를 지원하는 TCP 포트를 입수한다. 시작 클릭 >> 검색 창에서 \"SQL Server 20xx Configuration Manager\" 클릭 >> \"SQL Server Network Configuration\" 트리 확장 >> “Protocols for <Instance Name>” 클릭(<Instance name>은 CDMDB 이름) >> “TCP/IP” 선택 >> “Properties” 선택 >> “IP Addresses” 탭 선택 >> TCP 포트 기록. SQL Server 서비스를 실행하는 서비스 계정을 입수. 시작 >> \"SQL Server 20xx Configuration Manager\" >> “SQL Server Service” 선택 >> 검토되는 CDMDB의 “Log On As” 컬럼에 리스트 된 계정 기록. PowerShell 윈도우나 명령줄을 기동하고, 다음 명령을 실행한다: “setspn -L <Service Account>” (예, setspn -L CONTOSO\\sql20xxsvc). 리턴된 “Registered Service Principal Names”을 검토한다. 만일 리스트가 다음 2 가지 서비스 보안-주체 이름을 가지지 않는다면, 조치가 필요하다: “MSSQLSvc/<Fully Qualified Domain Name>, MSSQLSvc/<Fully Qualified Domain Name>:<TCP Port>”. 만일 MSSQLSvc 서비스가 현재 서버와 일치하지 않은 전체 주소 도메인 이름으로 등록되었다면, 서비스 계정이 SQL Server 인스턴스에 걸쳐 공유된다는 표시이다. 서버 문서를 검토한다. 만일 인스턴스에 걸친 서비스 계정 공유가 문서화되지 않고 인가 받지 않았다면, 조치가 필요하다. ",
    "Check_sql": null,
    "Fix": "SPN(Service Principal Names)가 SQL Server 인스턴스에 적절하게 등록되어야 한다. 해당 SQL Server 인스턴스의 커버러스 구성 문제를 검토하기 위해 MS Kerberos Configuration Manager를 활용한다. “https://www.MS.com/en-us/download/details.aspx?id=39046”를 참조하기 바란다. 다른 방법으로, SQL Server SPN은 수동적으로 등록될 수 있다: SPN을 등록하도록 인가 받은 계정을 사용하여, 다음 명령을 실행한다: “setspn -S MSSQLSvc/<Fully Qualified Domain Name> <Service Account> setspn -S MSSQLSvc/<Fully Qualified Domain Name>:<TCP Port> <Service Account>” CDMDB를 재시작한다. 이 프로세스에 관한 상세한 정보는 “https://docs.MS.com/en-us/sql/database-engine/configure-windows/register-a-service-principal-name-for-kerberos-connections#Manual“를 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79125",
    "Risk": "H",
    "Status": "Ready",
    "Subject": "CDMDB는 가용한 접근 통제 정책에 따라 정보와 시스템 자원의 논리적 접근에 대해 승인된 인가를 강제해야 한다.",
    "Check": "로그인 유형 별로 DBMS 서버 보안-개체를 위해 필요한 보호 수준을 판단하기 위해 시스템 문서를 검토한다. 서버에서 인가가 실제로 적절한지 검토한다. 만일 실제 허가가 문서화된 요구사항과 일치하지 않는다면, 조치가 필요하다. \"Instance permissions assignments to logins and roles.sql\"를 참조하기 바란다. ",
    "Check_sql": null,
    "Fix": "서버 보안-개체를 위해 허가를 추가/삭제하기 위해 “GRANT, REVOKE, DENY, ALTER SERVER ROLE ... ADD MEMBER ... 및 ALTER SERVER ROLE ...  DROP MEMBER” 구문을 사용하고, 요구사항에 문서화 한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79127",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 모든 계정이 별개, 유일 및 비-공유되도록 보장하여, 부정하게 부인하는 사용자에 대응하여 보호되어야 한다.",
    "Check": "시스템 문서에서 인가된 CDMDB 계정 목록을 입수한다. 계정이 공유되는지 판단한다. 공유 계정은 SQL Server에 로그인하기 위해 여러 개인이 사용하는 사용자명과 패스워드로 정의된다. 공유 계정의 예제는 SQL Server 설치 계정이다. Windows 그룹은 그룹 자체가 패스워드를 가지지 않기 때문에 공유 계정이 아니다. 계정이 공유된다고 판단되면, 개인이 먼저 개별적으로 인증되었는지 판단한다. 만일 개인이 공유 계정(예, 운영체제나 데이터베이스를 호출하는 애플리케이션에 의해)을 사용하기 전에 개별적으로 인증되지 않았다면, 조치가 필요하다. 핵심 사항은 개별 책무이다. 만일 추적 관리된다면, 조치가 필요하지 않다. 만일 계정이 공유된다고 판단된다면, 최종사용자가 이 계정을 직접적으로 접근할 수 있는지 판단한다. 만일 그렇다면, 조치가 필요하다. 동작을 수행하는 개별 사용자의 신원이 밝혀지도록 감사 로그, 트레이스 및 데이터 테이블의 내용을 검토한다. 만일 공유된 식별자가 발견되고 개별 식별자와 결합하지 않는다면, 조치가 필요하다. 주: 특권화된 설치 계정은 시스템 유지보수를 위해 DBA나 관리자가 접근해야 한다. 이런 경우에, 각 계정 사용이 계정 사용 동안에 수행된 동작의 책무를 배정하기 위한 어떤 방식으로 로깅 되어야 한다.",
    "Check_sql": null,
    "Fix": "사용자가 접근할 수 있는 공유 계정을 제거하고 개별 사용자 ID를 사용한다. 공유 계정 접근 전에 성공적인 개별 인증을 보장하기 위해 애플리케이션을 구성하고 빌드 한다. 각 사용자 신원이 모든 상황에서 감사 데이터로 수신되고 사용되도록 한다. 한 사람 이상이 접근하는 계정의 사용을 로깅하기 위한 방법을 설계/개발/구현 한다. 가능하면 적은 사람이 공유 계정을 접근하도록 제한한다. ",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79129",
    "Risk": "H",
    "Status": "Ready",
    "Subject": "CDMDB는 “NT AUTHORITY SYSTEM” 계정이 관리에 사용되지 않도록 보장하여, 부정하게 부인하는 사용자에 대응하여 보호되어야 한다. ",
    "Check": "“NT AUTHORITY SYSTEM(SYSTEM)”에 허용된 허가를 리스트 하기 위해 다음 쿼리를 실행한다: ”EXECUTE AS LOGIN = 'NT AUTHORITY\\SYSTEM' SELECT * FROM fn_my_permissions(NULL,NULL) REVERT;”. 만일 허가가 “CONNECT SQL\" 및 \"VIEW ANY DATABASE\"을 넘게 “SYSTEM”에 허용되었다면, 조치가 필요하다.  ",
    "Check_sql": [
      "EXECUTE AS LOGIN = 'NT AUTHORITY\\SYSTEM' SELECT * FROM fn_my_permissions(NULL,NULL) REVERT;",
      "VIEW ANY DATABASE\"을 넘게 “SYSTEM;"
    ],
    "Fix": "점검 사항에서 허용되도록 식별되지 않은 역할/매핑/허가를 선택-해제한다. 서비스/애플리케이션에 허가를 허용하기 위해, 도메인 서비스 계정이나 서비스의 “Service SID”를 활용한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79131",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 명백하게 유일한 액티브 디렉터리 사용자 계정 만이 CDMDB를 접근할 수 있도록 보장하여, 부정하게 부인하는 사용자에 대응하여 보호되어야 한다.",
    "Check": "다음 쿼리를 실행한다: “SELECT name FROM sys.server_principals WHERE type in ('U','G') AND name LIKE '%$';”. 만일 로그인이 리턴되지 않는다면, 조치가 필요하지 않다. 만일 로그인이 리턴 된다면, 각 로그인이 컴퓨터 계정인지 여부를 판단한다. PowerShell을 기동하여 다음 코드를 실행한다: “([ADSISearcher]\"(&(ObjectCategory=Computer)(Name=<name>))\").FindAll()” 주: <name>은 로그인 사용자 이름이다. 예를 들어, 로그인이 “CONTOSO\\user1$”이면 사용자 이름은 “user1”이다. 만일 계정 정보가 리턴되지 않는다면, 조치가 필요하지 않다. 만일 계정 정보가 리턴 된다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name FROM sys.server_principals WHERE type in ('U','G') AND name LIKE '%$';"
    ],
    "Fix": "점검 사항에서 리턴된 모든 로그인을 삭제한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79133",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 모든 DBMS/데이터베이스 컴포넌트 내에 조직-정의 감사 이벤트에 감사 레코드를 생성하도록 구성되어야 한다.",
    "Check": "추가 이벤트가 감사하기 위해 필요한지 판단하기 위해 서버 문서를 검토한다. 만일 추가 이벤트가 필요하지 않다면, 조치가 필요하지 않다. 모든 설치된 감사를 가져오기 위해 다음 쿼리를 실행한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. CDMDB의 모든 현재 정의된 감사가 리스트 된다. 만일 감사가 리턴되지 않는다면, 조치가 필요하다. 감사가 되는 동작을 보기 위해, 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1;”. 생성된 감사 이벤트 목록과 문서를 비교한다. 만일 누락된 이벤트가 있다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1;"
    ],
    "Fix": "CDMDB STIG 보안 준수 감사 명세 서버 문서에 모든 필요한 감시 이벤트를 추가한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79135",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 어떤 감사 이벤트가 감사되는지의 선택 권한을 ISSM(ISSM이 지정한 역할/개인)에게만 허용되어야 한다.",
    "Check": "시스템 문서에서 승인된 감사 유지 관리자 목록을 입수한다. “sysadmin/ dbceator” 역할 멤버십(감사 정의를 생성하고 유지 관리하는 능력을 활성화 할 수 있는)을 가진 개별 로그인과 서버 역할을 검토한다. “ALTER ANY SERVER AUDIT, CONTROL SERVER, ALTER ANY DATABASE, CREATE ANY DATABASE” 허가(감사 정의를 생성하고 유지 관리하는 능력을 활성화 할 수 있는)를 가진 개별 로그인과 서버 역할을 검토한다. 리스트 된 허가를 가진 역할과 로그인을 판단하기 위해 다음 쿼리를 사용한다: “SELECT-- DISTINCT CASE WHEN SP.class_desc IS NOT NULL THEN CASE WHEN SP.class_desc = 'SERVER' AND S.is_linked = 0 THEN 'SERVER' WHEN SP.class_desc = 'SERVER' AND S.is_linked = 1 THEN 'SERVER (linked)' ELSE SP.class_desc END WHEN E.name IS NOT NULL THEN 'ENDPOINT' WHEN S.name IS NOT NULL AND S.is_linked = 0 THEN 'SERVER' WHEN S.name IS NOT NULL AND S.is_linked = 1 THEN 'SERVER (linked)' WHEN P.name IS NOT NULL THEN 'SERVER_PRINCIPAL' ELSE '???' END                    AS [Securable Class], CASE WHEN E.name IS NOT NULL THEN E.name WHEN S.name IS NOT NULL THEN S.name WHEN P.name IS NOT NULL THEN P.name ELSE '???' END AS [Securable], P1.name AS [Grantee], P1.type_desc AS [Grantee Type], sp.permission_name AS [Permission], sp.state_desc AS [State], P2.name AS [Grantor], P2.type_desc AS [Grantor Type], R.name AS [Role Name] FROM sys.server_permissions SP INNER JOIN sys.server_principals P1 ON P1.principal_id = SP.grantee_principal_id INNER JOIN sys.server_principals P2 ON P2.principal_id = SP.grantor_principal_id FULL OUTER JOIN sys.servers S ON  SP.class_desc = 'SERVER' AND S.server_id = SP.major_id FULL OUTER JOIN sys.endpoints E ON  SP.class_desc = 'ENDPOINT' AND E.endpoint_id = SP.major_id FULL OUTER JOIN sys.server_principals P ON  SP.class_desc = 'SERVER_PRINCIPAL' AND P.principal_id = SP.major_id FULL OUTER JOIN sys.server_role_members SRM ON P.principal_id = SRM.member_principal_id LEFT OUTER JOIN sys.server_principals R ON SRM.role_principal_id = R.principal_id WHERE sp.permission_name IN ('ALTER ANY SERVER AUDIT','CONTROL SERVER','ALTER ANY DATABASE','CREATE ANY DATABASE') OR R.name IN ('sysadmin','dbcreator');”. 만일 리턴된 로그인, 역할이나 역할 멤버십이 문서화되지 않은 허가를 가지거나, 문서화된 감사 유지 관리자가 허가를 가지지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "ALTER ANY SERVER AUDIT, CONTROL SERVER, ALTER ANY DATABASE, CREATE ANY DATABASE;",
      "SELECT-- DISTINCT CASE WHEN SP.class_desc IS NOT NULL THEN CASE WHEN SP.class_desc = 'SERVER' AND S.is_linked = 0 THEN 'SERVER' WHEN SP.class_desc = 'SERVER' AND S.is_linked = 1 THEN 'SERVER (linked)' ELSE SP.class_desc END WHEN E.name IS NOT NULL THEN 'ENDPOINT' WHEN S.name IS NOT NULL AND S.is_linked = 0 THEN 'SERVER' WHEN S.name IS NOT NULL AND S.is_linked = 1 THEN 'SERVER (linked)' WHEN P.name IS NOT NULL THEN 'SERVER_PRINCIPAL' ELSE '???' END                    AS [Securable Class], CASE WHEN E.name IS NOT NULL THEN E.name WHEN S.name IS NOT NULL THEN S.name WHEN P.name IS NOT NULL THEN P.name ELSE '???' END AS [Securable], P1.name AS [Grantee], P1.type_desc AS [Grantee Type], sp.permission_name AS [Permission], sp.state_desc AS [State], P2.name AS [Grantor], P2.type_desc AS [Grantor Type], R.name AS [Role Name] FROM sys.server_permissions SP INNER JOIN sys.server_principals P1 ON P1.principal_id = SP.grantee_principal_id INNER JOIN sys.server_principals P2 ON P2.principal_id = SP.grantor_principal_id FULL OUTER JOIN sys.servers S ON  SP.class_desc = 'SERVER' AND S.server_id = SP.major_id FULL OUTER JOIN sys.endpoints E ON  SP.class_desc = 'ENDPOINT' AND E.endpoint_id = SP.major_id FULL OUTER JOIN sys.server_principals P ON  SP.class_desc = 'SERVER_PRINCIPAL' AND P.principal_id = SP.major_id FULL OUTER JOIN sys.server_role_members SRM ON P.principal_id = SRM.member_principal_id LEFT OUTER JOIN sys.server_principals R ON SRM.role_principal_id = R.principal_id WHERE sp.permission_name IN ('ALTER ANY SERVER AUDIT','CONTROL SERVER','ALTER ANY DATABASE','CREATE ANY DATABASE') OR R.name IN ('sysadmin','dbcreator');"
    ],
    "Fix": "감사 유지 관리자에 특정적인 서버 역할을 생성하고 불필요한 허가 허용 없이 감사를 유지 관리하도록 권한을 준다(여기에서 사용되는 역할 이름은 예제이고 다른 이름을 사용할 수도 있음): “CREATE SERVER ROLE SERVER_AUDIT_MAINTAINERS; GO GRANT ALTER ANY SERVER AUDIT TO SERVER_AUDIT_MAINTAINERS; GO Use REVOKE and/or DENY and/or ALTER SERVER ROLE ... DROP MEMBER ... statements to remove the ALTER ANY SERVER AUDIT permission from all logins;”. 그런 다음에, 각 인가된 로그인에 대하여 다음 구문을 실행한다: “ALTER SERVER ROLE SERVER_AUDIT_MAINTAINERS ADD MEMBER; GO”. 필요하지 않은 로그인으로부터 CONTROL SERVER, ALTER ANY DATABASE 및 CREATE ANY DATABASE 허가를 제거하기 위해 REVOKE, DENY, ALTER SERVER ROLE ... DROP MEMBER ... 구문을 사용한다.",
    "Fix_sql": [
      "CREATE SERVER ROLE SERVER_AUDIT_MAINTAINERS;",
      "GO GRANT ALTER ANY SERVER AUDIT TO SERVER_AUDIT_MAINTAINERS;",
      "GO Use REVOKE and/or DENY and/or ALTER SERVER ROLE ... DROP MEMBER ... statements to remove the ALTER ANY SERVER AUDIT permission from all logins;",
      "ALTER SERVER ROLE SERVER_AUDIT_MAINTAINERS ADD MEMBER;",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79137",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 권한/허가가 조회될 때 감사 레코드를 생성해야 한다.",
    "Check": "CDMDB가 권한/허가/역할 멤버십 정보 조회의 감사를 필요로 하는지 판단하기 위해 시스템 문서를 검토한다. 만일 CDMDB가 권한/허가/역할 멤버십 정보 조회의 감사가 필요하지 않다면, 조치가 필요하지 않다. 만일 문서가 존재하지 않는다면, 조치가 필요하다. 다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. 만일 권한/허가/역할 멤버십 정보 조회의 감사가 필요하다면, “SCHEMA_OBJECT_ACCESS_GROUP”이 서버 감사 명세에 포함되었는지 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';”. 만일 “SCHEMA_OBJECT_ACCESS_GROUP”이 활성 감사에서 리턴되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';"
    ],
    "Fix": "만일 CDMDB가 권한/허가/역할 멤버십 정보 조회의 감사가 필요하다면, 이런 정보를 추출하기 위한 전용 감사를 생성한다”USE [master]; GO Set variables needed by setup script: DECLARE @auditName varchar(50), @auditPath varchar(260), @auditGuid uniqueidentifier, @auditFileSize varchar(4), @auditFileCount varchar(4)”. 감사 이름을 정의한다: “SET @auditName = 'STIG_Audit_Permissions_Queries'”. 감사 로그 파일이 저장되는 디렉터리를 정의한다: “SET @auditPath = 'C:\\Program Files\\MS SQL Server\\MSSQL13.SQL20xx\\MSSQL\\Audits'”. 유일 감사 식별자를 정의한다: “SET @auditGuid = NEWID()”. 단일 감사 파일의 최대 크기(MB)를 정의한다: “SET @auditFileSize = 200”. 온라인으로 유지되어야 하는 파일 개수를 정의한다. 무제한으로 Use-1: “SET @auditFileCount = 50”. 임시 테이블에 변수를 삽입하여, 스크립트 동안에 생존한다: “CREATE TABLE #SetupVars ( Variable varchar(50), Value  varchar(260) ) INSERT INTO #SetupVars (Variable, Value) VALUES ('auditName', @auditName), ('auditPath', @auditPath),     ('auditGuid', convert(varchar(40), @auditGuid)), ('auditFileSize', @auditFileSize),     ('auditFileCount', @auditFileCount) GO”. 감사가 현재 존재한다면 삭제한다. Server Audit Specification을 비활성화 한다: “DECLARE @auditName varchar(50), @disableSpecification nvarchar(max) SET  @auditName = (SELECT Value FROM #SetupVars WHERE Variable = 'auditName') SET  @disableSpecification = ' IF EXISTS (SELECT 1 FROM sys.server_audit_specifications WHERE name = N''' + @auditName + '_SERVER_SPECIFICATION'') ALTER SERVER AUDIT SPECIFICATION [' + @auditName + '_SERVER_SPECIFICATION] WITH (STATE = OFF);' EXEC(@disableSpecification) GO”. Server Audit Specification을 삭제한다: “DECLARE @auditName varchar(50), @dropSpecification nvarchar(max) SET  @auditName = (SELECT Value FROM #SetupVars WHERE Variable = 'auditName') SET  @dropSpecification = ' IF EXISTS (SELECT 1 FROM sys.server_audit_specifications WHERE name = N''' + @auditName + '_SERVER_SPECIFICATION'') DROP SERVER AUDIT SPECIFICATION [' + @auditName + '_SERVER_SPECIFICATION];' EXEC(@dropSpecification) GO”. Server Audit을 비활성화 한다: “DECLARE @auditName varchar(50), @disableAudit nvarchar(max) SET  @auditName = (SELECT Value FROM #SetupVars WHERE Variable = 'auditName') SET  @disableAudit = ' IF EXISTS (SELECT 1 FROM sys.server_audits WHERE name = N''' + @auditName + ''') ALTER SERVER AUDIT [' + @auditName + '] WITH (STATE = OFF);' EXEC(@disableAudit) GO”. Server Audit을 삭제한다: “DECLARE @auditName varchar(50), @dropAudit nvarchar(max) SET  @auditName = (SELECT Value FROM #SetupVars WHERE Variable = 'auditName') SET  @dropAudit = ' IF EXISTS (SELECT 1 FROM sys.server_audits WHERE name = N''' + @auditName + ''') DROP SERVER AUDIT [' + @auditName + '];' EXEC(@dropAudit) GO”. Server Audit을 설정한다: “USE [master]; GO”. Server Audit을 생성한다: “DECLARE @auditName varchar(50), @auditPath varchar(260), @auditGuid varchar(40), @auditFileSize varchar(4), @auditFileCount varchar(5) SELECT @auditName = Value FROM #SetupVars WHERE Variable = 'auditName' SELECT @auditPath = Value FROM #SetupVars WHERE Variable = 'auditPath' SELECT @auditGuid = Value FROM #SetupVars WHERE Variable = 'auditGuid' SELECT @auditFileSize = Value FROM #SetupVars WHERE Variable = 'auditFileSize' SELECT @auditFileCount = Value FROM #SetupVars WHERE Variable = 'auditFileCount' DECLARE @createStatement nvarchar(max) SET  @createStatement = ' CREATE SERVER AUDIT [' + @auditName + '] TO FILE ( FILEPATH = ''' + @auditPath + ''' , MAXSIZE = ' + @auditFileSize + ' MB , MAX_ROLLOVER_FILES = ' + CASE WHEN @auditFileCount = -1 THEN 'UNLIMITED' ELSE @auditFileCount END + ' , RESERVE_DISK_SPACE = OFF ) WITH (   QUEUE_DELAY = 1000 , ON_FAILURE = SHUTDOWN , AUDIT_GUID = ''' + @auditGuid + ''' ) WHERE ([Schema_Name] = ''sys'' AND [Object_Name] = ''all_objects'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''database_permissions'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''database_principals'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''database_role_members'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''dm_column_store_object_pool'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''dm_db_xtp_object_stats'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''dm_os_memory_objects'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''dm_xe_object_columns'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''dm_xe_objects'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''dm_xe_session_object_columns'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''filetable_system_defined_objects'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''linked_logins'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''login_token'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''objects'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''remote_logins'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''server_permissions'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''server_principal_credentials'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''server_principals'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''server_role_members'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''sql_logins'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''syscacheobjects'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''syslogins'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''sysobjects'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''sysoledbusers'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''syspermissions'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''sysremotelogins'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''system_objects'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''sysusers'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''user_token'') ' EXEC(@createStatement) GO”. Audit을 활성화 한다: “DECLARE @auditName varchar(50), @enableAudit nvarchar(max) SET @auditName = (SELECT Value FROM #SetupVars WHERE Variable = 'auditName') SET @enableAudit = ' IF EXISTS (SELECT 1 FROM sys.server_audits WHERE name = N''' + @auditName + ''') ALTER SERVER AUDIT [' + @auditName + '] WITH (STATE = ON);' EXEC(@enableAudit) GO”. Server Audit Specification을 생성한다: “DECLARE @auditName varchar(50), @createSpecification nvarchar(max) SET  @auditName = (SELECT Value FROM #SetupVars WHERE Variable = 'auditName') SET  @createSpecification = ' CREATE SERVER AUDIT SPECIFICATION [' + @auditName + '_SERVER_SPECIFICATION] FOR SERVER AUDIT [' + @auditName + '] ADD (SCHEMA_OBJECT_ACCESS_GROUP) WITH (STATE = ON);' EXEC(@createSpecification) GO”. 정리 삭제한다: “DROP TABLE #SetupVars;”.",
    "Fix_sql": [
      "USE [master];",
      "GO Set variables needed by setup script: DECLARE @auditName varchar(50), @auditPath varchar(260), @auditGuid uniqueidentifier, @auditFileSize varchar(4), @auditFileCount varchar(4);",
      "SET @auditName = 'STIG_Audit_Permissions_Queries';",
      "SET @auditPath = 'C:\\Program Files\\MS SQL Server\\MSSQL13.SQL20xx\\MSSQL\\Audits';",
      "SET @auditGuid = NEWID();",
      "SET @auditFileSize = 200;",
      "SET @auditFileCount = 50;",
      "CREATE TABLE #SetupVars ( Variable varchar(50), Value  varchar(260) ) INSERT INTO #SetupVars (Variable, Value) VALUES ('auditName', @auditName), ('auditPath', @auditPath),     ('auditGuid', convert(varchar(40), @auditGuid)), ('auditFileSize', @auditFileSize),     ('auditFileCount', @auditFileCount) GO;",
      "DECLARE @auditName varchar(50), @disableSpecification nvarchar(max) SET  @auditName = (SELECT Value FROM #SetupVars WHERE Variable = 'auditName') SET  @disableSpecification = ' IF EXISTS (SELECT 1 FROM sys.server_audit_specifications WHERE name = N''' + @auditName + '_SERVER_SPECIFICATION'') ALTER SERVER AUDIT SPECIFICATION [' + @auditName + '_SERVER_SPECIFICATION] WITH (STATE = OFF);",
      "EXEC(@disableSpecification) GO;",
      "DECLARE @auditName varchar(50), @dropSpecification nvarchar(max) SET  @auditName = (SELECT Value FROM #SetupVars WHERE Variable = 'auditName') SET  @dropSpecification = ' IF EXISTS (SELECT 1 FROM sys.server_audit_specifications WHERE name = N''' + @auditName + '_SERVER_SPECIFICATION'') DROP SERVER AUDIT SPECIFICATION [' + @auditName + '_SERVER_SPECIFICATION];",
      "EXEC(@dropSpecification) GO;",
      "DECLARE @auditName varchar(50), @disableAudit nvarchar(max) SET  @auditName = (SELECT Value FROM #SetupVars WHERE Variable = 'auditName') SET  @disableAudit = ' IF EXISTS (SELECT 1 FROM sys.server_audits WHERE name = N''' + @auditName + ''') ALTER SERVER AUDIT [' + @auditName + '] WITH (STATE = OFF);",
      "EXEC(@disableAudit) GO;",
      "DECLARE @auditName varchar(50), @dropAudit nvarchar(max) SET  @auditName = (SELECT Value FROM #SetupVars WHERE Variable = 'auditName') SET  @dropAudit = ' IF EXISTS (SELECT 1 FROM sys.server_audits WHERE name = N''' + @auditName + ''') DROP SERVER AUDIT [' + @auditName + '];",
      "EXEC(@dropAudit) GO;",
      "USE [master];",
      "GO;",
      "DECLARE @auditName varchar(50), @auditPath varchar(260), @auditGuid varchar(40), @auditFileSize varchar(4), @auditFileCount varchar(5) SELECT @auditName = Value FROM #SetupVars WHERE Variable = 'auditName' SELECT @auditPath = Value FROM #SetupVars WHERE Variable = 'auditPath' SELECT @auditGuid = Value FROM #SetupVars WHERE Variable = 'auditGuid' SELECT @auditFileSize = Value FROM #SetupVars WHERE Variable = 'auditFileSize' SELECT @auditFileCount = Value FROM #SetupVars WHERE Variable = 'auditFileCount' DECLARE @createStatement nvarchar(max) SET  @createStatement = ' CREATE SERVER AUDIT [' + @auditName + '] TO FILE ( FILEPATH = ''' + @auditPath + ''' , MAXSIZE = ' + @auditFileSize + ' MB , MAX_ROLLOVER_FILES = ' + CASE WHEN @auditFileCount = -1 THEN 'UNLIMITED' ELSE @auditFileCount END + ' , RESERVE_DISK_SPACE = OFF ) WITH (   QUEUE_DELAY = 1000 , ON_FAILURE = SHUTDOWN , AUDIT_GUID = ''' + @auditGuid + ''' ) WHERE ([Schema_Name] = ''sys'' AND [Object_Name] = ''all_objects'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''database_permissions'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''database_principals'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''database_role_members'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''dm_column_store_object_pool'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''dm_db_xtp_object_stats'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''dm_os_memory_objects'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''dm_xe_object_columns'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''dm_xe_objects'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''dm_xe_session_object_columns'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''filetable_system_defined_objects'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''linked_logins'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''login_token'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''objects'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''remote_logins'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''server_permissions'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''server_principal_credentials'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''server_principals'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''server_role_members'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''sql_logins'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''syscacheobjects'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''syslogins'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''sysobjects'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''sysoledbusers'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''syspermissions'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''sysremotelogins'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''system_objects'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''sysusers'') OR ([Schema_Name] = ''sys'' AND [Object_Name] = ''user_token'') ' EXEC(@createStatement) GO;",
      "DECLARE @auditName varchar(50), @enableAudit nvarchar(max) SET @auditName = (SELECT Value FROM #SetupVars WHERE Variable = 'auditName') SET @enableAudit = ' IF EXISTS (SELECT 1 FROM sys.server_audits WHERE name = N''' + @auditName + ''') ALTER SERVER AUDIT [' + @auditName + '] WITH (STATE = ON);",
      "EXEC(@enableAudit) GO;",
      "DECLARE @auditName varchar(50), @createSpecification nvarchar(max) SET  @auditName = (SELECT Value FROM #SetupVars WHERE Variable = 'auditName') SET  @createSpecification = ' CREATE SERVER AUDIT SPECIFICATION [' + @auditName + '_SERVER_SPECIFICATION] FOR SERVER AUDIT [' + @auditName + '] ADD (SCHEMA_OBJECT_ACCESS_GROUP) WITH (STATE = ON);",
      "EXEC(@createSpecification) GO;",
      "DROP TABLE #SetupVars;"
    ]
  },
  {
    "Id": "CDMV-79139",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 권한/허가 조회 시도가 실패할 경우에 감사 레코드를 생성해야 한다. ",
    "Check": "CDMDB가 권한/허가/역할 멤버십 정보 조회의 감사를 필요로 하는지 판단하기 위해 시스템 문서를 검토한다. 만일 CDMDB가 권한/허가/역할 멤버십 정보 조회의 감사가 필요하지 않다면, 조치가 필요하지 않다. 만일 문서가 존재하지 않는다면, 조치가 필요하다. 다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. 만일 권한/허가/역할 멤버십 정보 조회의 감사가 필요하다면, “SCHEMA_OBJECT_ACCESS_GROUP”이 서버 감사 명세에 포함되었는지 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';”. 만일 “SCHEMA_OBJECT_ACCESS_GROUP”이 활성 감사에서 리턴되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';"
    ],
    "Fix": "권한/허가/역할 멤버십 정보 조회를 감사하는 감사를 적용한다. “SQL 2016 Audit.sql” 파일을 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79141",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 시작 시에 세션 감사를 개시해야 한다.",
    "Check": "감사가 활성화일 경우에, 데이터베이스가 시작할 때 개시된다. “https://msdn.MS.com/en-us/library/cc280386.aspx#Anchor_2”를 참조하기 바란다. 다음 쿼리를 실행하여 감사가 구성되고 활성화인지를 확인한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status WHERE status_desc = 'STARTED';”. 모든 현재 정의된 데이터베이스 감사가 리스트 된다. 만일 감사가 리턴되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status WHERE status_desc = 'STARTED';"
    ],
    "Fix": "시스템 시작 시에 자동적으로 개시되도록 “SQL Audit”을 구성한다: “ALTER SERVER AUDIT [<Server Audit Name>] WITH STATE = ON”. 다음 쿼리를 실행한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status WHERE status_desc = 'STARTED';”. SQL STIG Audit이 시작 시에 세션 감사를 개시하도록 구성해야 한다.",
    "Fix_sql": [
      "ALTER SERVER AUDIT [<Server Audit Name>] WITH STATE = ON;",
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status WHERE status_desc = 'STARTED';"
    ]
  },
  {
    "Id": "CDMV-79143",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 인가된 사용자가 사용자 세션과 연관된 모든 내용을 추출/기록/로깅 할 수 있도록 구성되어야 한다. ",
    "Check": "세션 감사가 필요한지 판단하기 위해 시스템 문서를 검토한다. 만일 세션 감사가 필요하지 않다면, 조치가 필요하지 않다. 만일 문서가 존재하지 않는다면, 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "SQL Server “Extended Events”는 사용자가 문제 해결이나 세션 활동 문서화에 필요한 많은 정보를 수집할 수 있는 높은 확장/구성 아키텍처를 가진다. “Extended Events”는 아주 작은 성능 자원을 사용하는 경량 성능 모니터링 시스템이다. “Extended Events”는 세션 데이터를 생성/변경/보기/분석하는 T-SQL 구문과 2 개 GUI를 제공한다. 감사는 감사 그룹 멤버나 sysadmin에게만 활성화 되어야 한다. 서버 감사를 생성/변경/삭제하기 위해, 보안-주체는 ALTER ANY SERVER AUDIT이나 CONTROL SERVER 허가를 필요로 한다. 감사 로그를 보려면 CONTROL SERVER 허가가 필요하다. 감사 유지 관리자에 특정적인 서버 역할을 생성하고, 불필요한 허가의 허용 없이 감사를 유지 관리하는 허가를 부여한다(여기에서 사용되는 역할 이름은 예제이고, 다른 이름이 사용될 수도 있음): “CREATE SERVER ROLE SERVER_AUDIT_MAINTAINERS; GO GRANT ALTER ANY SERVER AUDIT TO SERVER_AUDIT_MAINTAINERS; GO”. 모든 로그인의 ALTER ANY SERVER AUDIT 허가를 제거하기 위해 REVOKE, DENY, ALTER SERVER ROLE ..., DROP MEMBER ... 구문을 사용한다. 그런 후에, 각 인가된 로그인에 다음 구문을 실행한다: “ALTER SERVER ROLE SERVER_AUDIT_MAINTAINERS ADD MEMBER; GO”. 필요하지 않은 로그인으로부터 CONTROL SERVER, ALTER ANY DATABASE 및 CREATE ANY DATABASE 허가를 제거하기 위해 REVOKE, DENY, ALTER SERVER ROLE ..., DROP MEMBER ... 구문을 사용한다.",
    "Fix_sql": [
      "ALTER ANY SERVER AUDIT이나 CONTROL SERVER 허가를 필요로 한다. 감사 로그를 보려면 CONTROL SERVER 허가가 필요하다. 감사 유지 관리자에 특정적인 서버 역할을 생성하고, 불필요한 허가의 허용 없이 감사를 유지 관리하는 허가를 부여한다(여기에서 사용되는 역할 이름은 예제이고, 다른 이름이 사용될 수도 있음): “CREATE SERVER ROLE SERVER_AUDIT_MAINTAINERS;",
      "GO GRANT ALTER ANY SERVER AUDIT TO SERVER_AUDIT_MAINTAINERS;",
      "GO;",
      "ALTER ANY SERVER AUDIT 허가를 제거하기 위해 REVOKE, DENY, ALTER SERVER ROLE ..., DROP MEMBER ... 구문을 사용한다. 그런 후에, 각 인가된 로그인에 다음 구문을 실행한다: “ALTER SERVER ROLE SERVER_AUDIT_MAINTAINERS ADD MEMBER;",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79145",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 유형/위치/대상 별로 식별된 감사 이벤트에 관하여 감사 레코드에 추가적이고 더 상세한 조직-정의 정보를 포함해야 한다",
    "Check": "만일 “SQL Server Audit”이 감사 목적으로 사용되지 않는다면, 제3자 제품이 상세한 감사를 수행하도록 사용되지 않는 한 조치가 필요하다. CDMDB가 표준 감사에 추가하여 이벤트나 필드의 감사가 필요한지 여부를 판단하기 위해 시스템 문서를 검토한다. 만일 명시된 것이 없다면, 조치가 필요하지 않다. 만일 “SQL Server Audit”이 사용된다면, 문서화된 요구사항과 감사 명세를 비교한다. 만일 이런 요구사항이 감사 명세나 보완 로컬-적용 메커니즘을 만족하지 않는다면, 조치가 필요하다. ",
    "Check_sql": null,
    "Fix": "모든 감사 이벤트와 데이터를 추출하는 감사를 설계하고 적용한다. 제3자 툴이 감사에 사용되는 경우, 제한되지는 않지만 이벤트, 유형, 위치, 대상, 일자/시간 및 변경자를 포함하여 모든 필요 정보를 담아야 한다. 추가 조직적 필요 정보를 추출하기 위해 추가 사용자-정의 감사를 구현한다. ",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79147",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 더 많은 감사 로그 레코드 공간 부족을 포함하여 감사 실패 시에 기본적으로 중지해야 하고, 감사 실패 시에 중지하도록 구성되어야 한다.",
    "Check": "만일 시스템 문서에서 가용성이 감사 추적 완전성 보다 우선한다면, 조치가 불가하다. 만일 “SQL Server Audit”이 사용된다면, 다음 구문을 실행하여 정의된 서버 감사를 검토한다: “SELECT * FROM sys.server_audits;”. [name]과 [is_state_enabled] 컬럼을 관찰하여, 사용 중인 row를 식별한다. 만일 row의 [on_failure_desc]가 \"SHUTDOWN SERVER INSTANCE\"라면, 조치가 필요하지 않다. 그렇지 않다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT * FROM sys.server_audits;"
    ],
    "Fix": "만일 “SQL Server Audit”가 사용된다면, 감사 로그 공간 부족을 포함하여 감사 실패 시에 중지하도록 “SQL Server Audit”을 구성한다: 각 식별된 감사에 T-SQL 스크립트를 실행한다: “ALTER SERVER AUDIT [AuditNameHere] WITH (STATE = OFF); GO ALTER SERVER AUDIT [AuditNameHere] WITH (ON_FAILURE = SHUTDOWN); GO ALTER SERVER AUDIT [AuditNameHere] WITH (STATE = ON); GO”.",
    "Fix_sql": [
      "ALTER SERVER AUDIT [AuditNameHere] WITH (STATE = OFF);",
      "GO ALTER SERVER AUDIT [AuditNameHere] WITH (ON_FAILURE = SHUTDOWN);",
      "GO ALTER SERVER AUDIT [AuditNameHere] WITH (STATE = ON);",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79149",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 더 많은 감사 로그 레코드의 공간이 부족할 경우에, 오래된 것부터 먼저(FIFO) 감사 로그 레코드를 덮어쓰기 하도록 구성해야 한다",
    "Check": "만일 시스템 문서에서 가용성이 감사 추적 완전성 보다 우선한다면, 조치가 불가하다. “SQL Server Audit”이 사용되지 않는다면, 조치가 필요하다. 만일 “SQL Server Audit”이 사용된다면, 다음 구문을 실행하여 정의된 서버 감사를 검토한다: “SELECT [name], [max_rollover_files] FROM sys.server_file_audits WHERE is_state_enabled = 1;”. [name]과 [max_rollover_files] 컬럼을 관찰하여, 사용 중인 row를 식별한다. 만일 [max_rollover_files]가 “0” 보다 크다면, 조치가 필요하지 않다. 그렇지 않다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT [name], [max_rollover_files] FROM sys.server_file_audits WHERE is_state_enabled = 1;"
    ],
    "Fix": "만일 “SQL Server Audit”이 사용된다면, 감사 실패 시에 가장 오래된 기존 레코드를 덮어쓰기 하여 감사 레코드를 생성 지속하도록 “SQL Server Audit”을 구성한다. 각 식별된 감사에 다음 T-SQL 스크립트를 실행한다: “ALTER SERVER AUDIT [AuditName] WITH (STATE = OFF); GO ALTER SERVER AUDIT [AuditName] to file (max_rollover_files = IntegerValue); GO ALTER SERVER AUDIT [AuditName] WITH (STATE = ON); GO”.",
    "Fix_sql": [
      "ALTER SERVER AUDIT [AuditName] WITH (STATE = OFF);",
      "GO ALTER SERVER AUDIT [AuditName] to file (max_rollover_files = IntegerValue);",
      "GO ALTER SERVER AUDIT [AuditName] WITH (STATE = ON);",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79151",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB가 생성한 감사 정보는 비인가 읽기 접근으로부터 보호되어야 한다.",
    "Check": "다음 SQL 스크립트를 실행하여 “SQL Server Audit” 파일 위치를 입수한다: “SELECT log_file_path AS \"Audit Path\" FROM sys.server_file_audits;”. 각 감사에서, “Audit Path” 컬럼은 파일 위치를 지정한다. 각 감사 파일에 다음 작업을 수행하여, 모든 감사 파일이 정확한 허가를 가졌는지 검증한다: 명령이나 Windows 탐색기를 사용하여 감사 폴더 위치를 탐색 >> 파일/폴더 오른쪽-클릭 >> “속성” 선택 >> “보안” 탭 선택. 최대한 다음 허가가 적용되었는지 검증한다; “Administrator (read) Users (none), Audit Administrator (Full Control), Auditors group (Read), SQL Server Service SID OR Service Account (Full Control), 만일 “SQL Server Agent”가 사용된다면 SQL Server SQL Agent Service SID OR Service Account (Read, Execute, Write)”. 만일 부족한 제한 허가가 존재한다면(명확하게 정의되고 승인되지 않는다면), 조치가 필요하다.",
    "Check_sql": [
      "SELECT log_file_path AS \"Audit Path\" FROM sys.server_file_audits;"
    ],
    "Fix": "비인가 접근에 대응하여 보호하기 위해 요구사항에 맞게 감사 파일 허가를 변경한다. 명령이나 Windows 탐색기를 사용하여 감사 폴더 위치를 탐색 >> 파일/폴더 오른쪽-클릭 >> “속성” 선택 >> “보안” 탭 선택. 보안 허가를 다음으로 수정한다; “Administrator (read) Users (none), Audit Administrator (Full Control), Auditors group (Read), SQL Server Service SID OR Service Account (Full Control), 만일 “SQL Server Agent”가 사용된다면 SQL Server SQL Agent Service SID OR Service Account (Read, Execute, Write)”. ",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79153",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB가 생성한 감사 정보는 비인가 변경으로부터 보호되어야 한다.",
    "Check": "다음 SQL 스크립트를 실행하여 “SQL Server Audit” 파일 위치를 입수한다: “SELECT log_file_path AS \"Audit Path\" FROM sys.server_file_audits;”. 각 감사에서, “Audit Path” 컬럼은 파일 위치를 지정한다. 각 감사 파일에 다음 작업을 수행하여, 모든 감사 파일이 정확한 허가를 가졌는지 검증한다: 명령이나 Windows 탐색기를 사용하여 감사 폴더 위치를 탐색 >> 파일/폴더 오른쪽-클릭 >> “속성” 선택 >> “보안” 탭 선택. 최대한 다음 허가가 적용되었는지 검증한다; “Administrator (read) Users (none), Audit Administrator (Full Control), Auditors group (Read), SQL Server Service SID OR Service Account (Full Control), 만일 “SQL Server Agent”가 사용된다면 SQL Server SQL Agent Service SID OR Service Account (Read, Execute, Write)”. 만일 부족한 제한 허가가 존재한다면(명확하게 정의되고 승인되지 않는다면), 조치가 필요하다.",
    "Check_sql": [
      "SELECT log_file_path AS \"Audit Path\" FROM sys.server_file_audits;"
    ],
    "Fix": "비인가 변경에 대응하여 보호하기 위해 요구사항에 맞게 감사 파일 허가를 변경한다. 명령이나 Windows 탐색기를 사용하여 감사 폴더 위치를 탐색 >> 파일/폴더 오른쪽-클릭 >> “속성” 선택 >> “보안” 탭 선택. 보안 허가를 다음으로 수정한다; “Administrator (read) Users (none), Audit Administrator (Full Control), Auditors group (Read), SQL Server Service SID OR Service Account (Full Control), 만일 “SQL Server Agent”가 사용된다면 SQL Server SQL Agent Service SID OR Service Account (Read, Execute, Write)”.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79155",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB가 생성한 감사 정보는 비인가 삭제로부터 보호되어야 한다.",
    "Check": "다음 SQL 스크립트를 실행하여 “SQL Server Audit” 파일 위치를 입수한다: “SELECT log_file_path AS \"Audit Path\" FROM sys.server_file_audits;”. 각 감사에서, “Audit Path” 컬럼은 파일 위치를 지정한다. 각 감사 파일에 다음 작업을 수행하여, 모든 감사 파일이 정확한 허가를 가졌는지 검증한다: 명령이나 Windows 탐색기를 사용하여 감사 폴더 위치를 탐색 >> 파일/폴더 오른쪽-클릭 >> “속성” 선택 >> “보안” 탭 선택. 최대한 다음 허가가 적용되었는지 검증한다; “Administrator (read) Users (none), Audit Administrator (Full Control), Auditors group (Read), SQL Server Service SID OR Service Account (Full Control), 만일 “SQL Server Agent”가 사용된다면 SQL Server SQL Agent Service SID OR Service Account (Read, Execute, Write)”. 만일 부족한 제한 허가가 존재한다면(명확하게 정의되고 승인되지 않는다면), 조치가 필요하다.",
    "Check_sql": [
      "SELECT log_file_path AS \"Audit Path\" FROM sys.server_file_audits;"
    ],
    "Fix": "비인가 삭제에 대응하여 보호하기 위해 요구사항에 맞게 감사 파일 허가를 변경한다. 명령이나 Windows 탐색기를 사용하여 감사 폴더 위치를 탐색 >> 파일/폴더 오른쪽-클릭 >> “속성” 선택 >> “보안” 탭 선택. 보안 허가를 다음으로 수정한다; “Administrator (read) Users (none), Audit Administrator (Full Control), Auditors group (Read), SQL Server Service SID OR Service Account (Full Control), 만일 “SQL Server Agent”가 사용된다면 SQL Server SQL Agent Service SID OR Service Account (Read, Execute, Write)”.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79157",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 비인가 접근으로부터 감사 기능을 보호해야 한다.",
    "Check": "“SQL Server Audits”을 접근하도록 승인된 사용자 목록에 관해 서버 문서를 검토한다. 서버 감사를 생성/변경/삭제하기 위해, 보안-주체는 “ALTER ANY SERVER AUDIT”나 “CONTROL SERVER” 허가가 필요하다. 감사 로그를 보려면, “CONTROL SERVER” 허가가 필요하다. “Profiler”를 사용하려면, “ALTER TRACE” 허가가 필요하다. 보안-주체에 허용된 SQL Server 허가를 검토한다. “ALTER ANY SERVER AUDIT, ALTER ANY DATABASE AUDIT, CONTROL SERVER, ALTER TRACE” 허가를 찾는다: “SELECT login.name, perm.permission_name, perm.state_desc FROM sys.server_permissions perm JOIN sys.server_principals login ON perm.grantee_principal_id = login.principal_id WHERE permission_name in ('CONTROL SERVER', 'ALTER ANY DATABASE AUDIT', 'ALTER ANY SERVER AUDIT','ALTER TRACE') and login.name not like '##MS_%';”. 만일 비인가 계정이 이런 권한을 가진다면, 조치가 필요하다. ",
    "Check_sql": [
      "ALTER ANY SERVER AUDIT;",
      "ALTER TRACE;",
      "ALTER ANY SERVER AUDIT, ALTER ANY DATABASE AUDIT, CONTROL SERVER, ALTER TRACE;",
      "SELECT login.name, perm.permission_name, perm.state_desc FROM sys.server_permissions perm JOIN sys.server_principals login ON perm.grantee_principal_id = login.principal_id WHERE permission_name in ('CONTROL SERVER', 'ALTER ANY DATABASE AUDIT', 'ALTER ANY SERVER AUDIT','ALTER TRACE') and login.name not like '##MS_%';"
    ],
    "Fix": "인가 되지 않은 개별 사용자나 역할로부터 감사-관련 허가를 삭제한다: “USE master; DENY [ALTER ANY SERVER AUDIT] TO [User]; GO”.",
    "Fix_sql": [
      "USE master;",
      "DENY [ALTER ANY SERVER AUDIT] TO [User];",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79159",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 비인가 변경으로부터 감사 기능을 보호해야 한다.",
    "Check": "“SQL Server Audits”을 접근하도록 승인된 사용자 목록에 관해 서버 문서를 검토한다. 서버 감사를 변경/삭제하기 위해, 보안-주체는 “ALTER ANY SERVER AUDIT”나 “CONTROL SERVER” 허가가 필요하다. 감사 로그를 보려면, “CONTROL SERVER” 허가가 필요하다. 보안-주체에 허용된 SQL Server 허가를 검토한다. “ALTER ANY SERVER AUDIT, ALTER ANY DATABASE AUDIT, CONTROL SERVER” 허가를 찾는다: “SELECT login.name, perm.permission_name, perm.state_desc FROM sys.server_permissions perm JOIN sys.server_principals login ON perm.grantee_principal_id = login.principal_id WHERE permission_name in ('CONTROL SERVER', 'ALTER ANY DATABASE AUDIT', 'ALTER ANY SERVER AUDIT') and login.name not like '##MS_%';”. 만일 비인가 계정이 이런 권한을 가진다면, 조치가 필요하다.",
    "Check_sql": [
      "ALTER ANY SERVER AUDIT;",
      "ALTER ANY SERVER AUDIT, ALTER ANY DATABASE AUDIT, CONTROL SERVER;",
      "SELECT login.name, perm.permission_name, perm.state_desc FROM sys.server_permissions perm JOIN sys.server_principals login ON perm.grantee_principal_id = login.principal_id WHERE permission_name in ('CONTROL SERVER', 'ALTER ANY DATABASE AUDIT', 'ALTER ANY SERVER AUDIT') and login.name not like '##MS_%';"
    ],
    "Fix": "인가 되지 않은 개별 사용자나 역할로부터 감사-관련 허가를 삭제한다: “USE master; DENY [ALTER ANY SERVER AUDIT] TO [User]; GO”.",
    "Fix_sql": [
      "USE master;",
      "DENY [ALTER ANY SERVER AUDIT] TO [User];",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79161",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 비인가 삭제로부터 감사 기능을 보호해야 한다.",
    "Check": "“SQL Server Audits”을 접근하도록 승인된 사용자 목록에 관해 서버 문서를 검토한다. 서버 감사를 변경/삭제하기 위해, 보안-주체는 “ALTER ANY SERVER AUDIT”나 “CONTROL SERVER” 허가가 필요하다. 감사 로그를 보려면, “CONTROL SERVER” 허가가 필요하다. 보안-주체에 허용된 SQL Server 허가를 검토한다. “ALTER ANY SERVER AUDIT, ALTER ANY DATABASE AUDIT, CONTROL SERVER” 허가를 찾는다: “SELECT login.name, perm.permission_name, perm.state_desc FROM sys.server_permissions perm JOIN sys.server_principals login ON perm.grantee_principal_id = login.principal_id WHERE permission_name in ('CONTROL SERVER', 'ALTER ANY DATABASE AUDIT', 'ALTER ANY SERVER AUDIT') and login.name not like '##MS_%';”. 만일 비인가 계정이 이런 권한을 가진다면, 조치가 필요하다.",
    "Check_sql": [
      "ALTER ANY SERVER AUDIT;",
      "ALTER ANY SERVER AUDIT, ALTER ANY DATABASE AUDIT, CONTROL SERVER;",
      "SELECT login.name, perm.permission_name, perm.state_desc FROM sys.server_permissions perm JOIN sys.server_principals login ON perm.grantee_principal_id = login.principal_id WHERE permission_name in ('CONTROL SERVER', 'ALTER ANY DATABASE AUDIT', 'ALTER ANY SERVER AUDIT') and login.name not like '##MS_%';"
    ],
    "Fix": "인가 되지 않은 개별 사용자나 역할로부터 감사-관련 허가를 삭제한다: “USE master; DENY [ALTER ANY SERVER AUDIT] TO [User]; GO”.",
    "Fix_sql": [
      "USE master;",
      "DENY [ALTER ANY SERVER AUDIT] TO [User];",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79163",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 소프트웨어 모듈과 외부 소프트웨어 링크를 변경하는 권한을 제한해야 한다.",
    "Check": "데이터베이스의 바이너리 파일을 변경 권한이 인가된 소유자, 사용자 및 그룹을 판단하기 위해 서버 문서를 검토한다. 추가적으로 디스크에 공유된 소프트웨어 라이브러리 경로의 변경 권한을 가진 소유자, 사용자 및 그룹을 점검한다. 만일 비인가 사용자가 변경 권한을 가지거나 소유자가 부정확하다면, 조치가 필요하다. 이런 데이터베이스 특정 바이너리의 위치를 판단하기 위해, SSMS 기동 >> 검토되는 데이터베이스 연결 >> Object Explorer에서 서버 이름 오른쪽-클릭 >> “Facets” 클릭 >> “Server facet” 선택 >> “RootDirectory” Facet 속성 값 기록”. 위 폴더를 탐색하고 “Binn” 서브디렉터리를 검토한다.",
    "Check_sql": null,
    "Fix": "인가된 계정에 디스크의 모든 공유 소프트웨어 라이브러리 소유권을 변경한다. 비인가 사용자나 그룹에 허용된 변경 허가를 제거한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79165",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 스토어드 프로시저, 함수, 트리거 및 외부 소프트웨어 링크를 포함하여 소프트웨어 모듈을 변경하는 권한을 제한해야 한다.",
    "Check": "공유 소프트웨어 라이브러리가 변경을 모니터링 하는 프로세스를 판단하기 위해 서버 문서를 검토한다. 프로세스가 최소한 파일 소유권 변경, 변경 일자 및 해시 값을 경보 해야 한다. 만일 경보가 최소한 값을 해시 하지 않는다면, 조치가 필요하다. 이런 데이터베이스-특정 라이브러리의 위치를 판단하기 위해, SSMS 기동 >> 검토되는 데이터베이스 연결 >> Object Explorer에서 서버 이름 오른쪽-클릭 >> “Facets” 클릭 >> “Server Facet” 선택 >> “RootDirectory” Facet 속성 값 기록”. 주: 하나 이상의 파일의 SHA-2 해시를 얻기 위해 PowerShell 5.0의 “Get-FileHash cmdlet”를 사용한다. ",
    "Check_sql": null,
    "Fix": "소프트웨어 라이브러리 변경이 모니터링 되고 경보 되는 프로세스를 구현하고 문서화 한다. PowerShell 기반 해싱 솔루션이 이런 프로세스 중 하나이다. “Get-FileHash” 명령이 하나 이상의 파일을 계산하는데 사용될 수 있다(“https://msdn.MS.com/en-us/powershell/reference/5.1/MS.powershell.utility/get-filehash” 참조). “Export-Clixml” 명령을 사용하여, 기준선이 설정되고 파일을 내보내기 할 수 있다(“https://msdn.MS.com/powershell/reference/5.1/MS.powershell.utility/Export-Clixml” 참조). “Compare-Object” 명령을 사용하여, 최신 기준선 대비 원래 기준선 비교가 차이를 파악하는데 사용될 수 있다(“https://technet.MS.com/en-us/library/ee156812.aspx” 참조)",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79167",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB 소프트웨어 설치 계정은 인가된 사용자로 제한되어야 한다.",
    "Check": "시스템 문서에서, CDMDB를 설치/갱신하도록 인가된 계정 목록을 입수한다. 데이터베이스 소프트웨어를 설치/변경한 모든 사용자를 리스트 하기 위해 다음 PowerShell 명령을 실행하고, 소프트웨어 사용이 인가되거나 권한이 있는 사람과 리스트를 비교한다: “sl \"C:\\program files\\MS sql server\\130\\setup bootstrap\\Log\" Get-ChildItem -Recurse | Select-String -Pattern \"LogonUser = \"”. 만일 계정이 시스템 문서에서 인가되지 않았다면, 조치가 필요하다. ",
    "Check_sql": null,
    "Fix": "명령 프롬프트에서, 로컬 사용자 및 그룹 “lusrmgr.msc”를 오픈 >> 사용자를 탐색 >> 개별 사용자를 오른쪽-클릭 >> “속성”을 선택하여 확인한다. 사용자의 사용/조회가 인가된 오브젝트와 데이터의 사용자 접근을 제한하기 위해 접근 통제와 운영체제/SQL Server 설정을 구성한다. ",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79169",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB DBMS 구성 파일을 포함하여 데이터베이스 소프트웨어는 호스트 운영체제나 다른 애플리케이션과 별개인 전용 디렉터리에 저장되어야 한다.",
    "Check": "CDMDB가 설치된 디렉터리를 판단한다. SSMS Object Explorer를 사용 >> [CDMDB] 오른쪽-클릭 >> “Facets” 선택 >> “RootDirectory” 값 기록. 운영체제 디렉터리를 판단한다: “시작” >> “Run” 입력 후 엔터키 >> \"%windir%\" 입력 >> “OK” 클릭 >> 주소 바의 값을 기록.  “RootDirectory”가 운영체제 디렉터리에 없는지 확인한다. “RootDirectory”와 운영체제 디렉터리를 비교한다. 만일 “RootDirectory”가 운영체제와 동일한 디렉터리라면, 조치가 필요하다. “RootDirectory”가 다른 애플리케이션 디렉터리에 있는지 검증한다. Windows 탐색기를 사용하여 “RootDirectory”를 탐색한다. 다른 애플리케이션이 저장되었는지 각 디렉터리를 확인한다. 만일 “RootDirectory”가 다른 애플리케이션 디렉터리에 존재한다면, 조치가 필요하다. 만일 “RootDirectory”가 운영체제나 다른 애플리케이션 디렉터리에 있지 않다면, 조치가 필요하지 않다. 예제: 1) 운영체제 디렉터리는 “C:\\Windows”, RootDirectory는 “C:\\Program Files\\MSSQLSERVER\\MSSQL\"라면, MSSQLSERVER 디렉터리가 운영체제나 다른 애플리케이션 디렉터리에 존재하지 않기 때문에, 조치가 필요하지 않다. 2) 운영체제 디렉터리는 “C:\\Windows”, RootDirectory는 “C:\\Windows\\MSSQLSERVER\\MSSQL\"라면, 조치가 필요하다. 3) 운영체제 디렉터리는 “C:\\Windows”, RootDirectory는 “C:\\Program Files\\MS Office\\MSSQLSERVER\\MSSQL\"라면, MSSQLSERVER 디렉터리가 MS Office 디렉터리에 있기 때문에, 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "운영체제와 별개인 전용 디렉터리를 사용하여 SQL Server 애플리케이션 컴포넌트를 재-설치한다. SQL Server 컴포넌트와 현재 디렉터리를 공유하는 다른 애플리케이션 소프트웨어를 재-배치하거나 재-설치한다. 운영체제와 임시 스토리지를 분리한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79171",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "디폴트 데모 및 샘플 데이터베이스, 데이터베이스 오브젝트 및 애플리케이션은 제거되어야 한다.",
    "Check": "이 시스템이 개발이나 테스트 시스템인지 서버 문서를 검토하고, 그렇다면 점검이 불가하다. 만일 시스템이 실행 시스템이라면, 서버에서 데이터베이스 목록을 수집하고, 다음 일반 데모 데이터베이스 이름을 찾는다: “pubs, Northwind, AdventureWorks, WorldwideImporters”. 만일 이런 데이터베이스가 존재한다면, 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "실행 시스템 데이터베이스에서 모든 데모/샘플 데이터베이스를 제거한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79173",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "사용되지 않은 데이터베이스 컴포넌트, DBMS 소프트웨어 및 데이터베이스 오브젝트는 제거되어야 한다.",
    "Check": "서버 문서에서, 필수 컴포넌트 목록을 입수한다. 서버에 설치된 컴포넌트 목록을 생성한다. Windows시작 >> \"SQL Server 20xx Installation Center\" 입력 >> 프로그램 기동 >> “Tools” 클릭 >> \"Installed SQL Server features discovery report\" 클릭. 필수 컴포넌트 목록과 기능 목록을 비교한다. 만일 기능이 설치되었지만 필요하지 않다면, 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "필요하지 않은 모든 기능은 제거한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79175",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "SQL Server에 통합되고 설치-제거가 될 수 없는, 사용하지 않는 데이터베이스 컴포넌트는 비활성화 되어야 한다.",
    "Check": "서버 문서에서, 필수 컴포넌트 목록을 입수한다. 서버에 설치된 컴포넌트 목록을 생성한다. Windows시작 >> \"SQL Server 20xx Installation Center\" 입력 >> 프로그램 기동 >> “Tools” 클릭 >> \"Installed SQL Server features discovery report\" 클릭. 필수 컴포넌트 목록과 기능 목록을 비교한다. 필요하지 않지만 설치된 컴포넌트를 기록한다. SQL Server Configuration manager를 기동한다. 만일 컴포넌트가 설치되었지만 필요하지 않고 비활성화 되지 않았다면, 조치가 필요하다. 만일 필수 컴포넌트가 설치되지 않았다면, 조치가 필요하다. ",
    "Check_sql": null,
    "Fix": "설치-제거할 수 없는 기능이나 사용하지 않은 컴포넌트는 비활성화 한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79177",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "“xp_cmdshell” 접근은 명확하게 필요하고 승인되지 않는 한 비활성화 되어야 한다.",
    "Check": "“xp_cmdshell” 확장 스토어드 프로시저는 데이터베이스 접근 허가 통제 외부에 있는 호스트 실행-모듈의 실행을 허용한다. 이런 접근은 추가적 악성 활동을 자행하고 호스트 운영체제를 통제하기 위해 SQL Server 데이터베이스의 무결성을 훼손한 악성 사용자로부터 악용될 수도 있다. “xp_cmdshell”이 활성화인지 판단하기 위해, 다음 명령을 실행한다: “EXEC SP_CONFIGURE 'show advanced options', '1'; RECONFIGURE WITH OVERRIDE; EXEC SP_CONFIGURE 'xp_cmdshell';”. 만일 “config_value” 값이 “0”이면, 조치가 필요하지 않다. “xp_cmdshell” 사용이 필요하고 승인되었는지 여부를 판단하기 위해 시스템 문서를 검토한다. 만일 승인되지 않았다면, 조치가 필요하다.",
    "Check_sql": [
      "EXEC SP_CONFIGURE 'show advanced options', '1';",
      "RECONFIGURE WITH OVERRIDE;",
      "EXEC SP_CONFIGURE 'xp_cmdshell';"
    ],
    "Fix": "인가 받지 않은 외부 애플리케이션 실행-모듈 오브젝트 정의를 제거하거나 사용을 비활성화 한다. “xp_cmdshell” 사용을 비활성화 하기 위해, 다음 쿼리를 실행한다: “EXEC sp_configure 'show advanced options', 1; GO RECONFIGURE; GO EXEC sp_configure 'xp_cmdshell', 0; GO RECONFIGURE; GO”. ",
    "Fix_sql": [
      "EXEC sp_configure 'show advanced options', 1;",
      "GO RECONFIGURE;",
      "GO EXEC sp_configure 'xp_cmdshell', 0;",
      "GO RECONFIGURE;",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79179",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "“CLR” 코드 접근은 명확하게 필요하고 승인되지 않는 한 제한되거나 비활성화 되어야 한다.",
    "Check": "SQL Server에서 MS Windows .NET 프레임워크의 “CLR(Common Language Runtime)” 컴포넌트를 통하여 사용자가 MS Visual Basic .NET 및 Visual C#을 포함하여 .NET 프레임워크 언어를 사용하는 스토어드 프로시저, 트리거, 사용자-정의 유형 함수, 사용자-정의 집계 및 스트리밍 테이블-값 함수를 작성할 수 있다. CLR 패킹 어셈블리는 관리성 코드를 실행할 때 .NET 코드 접근 보안에 의해 보호된 자원을 접근할 수 있다. “UNSAFE”를 명시하면 SQL Server의 견고성을 훼손할 수 있는 작업을 SQL Server 프로세스 공간에 수행하는데 완벽하게 자유로운 코드가 가능하게 된다. “UNSAFE” 어셈블리는 SQL Server나 CLR의 보안 시스템을 와해시킬 수도 있다. “CLR”이 활성화 되었는지 판단하기 위해, 다음 명령을 실행한다: “EXEC SP_CONFIGURE 'show advanced options', '1'; RECONFIGURE WITH OVERRIDE; EXEC SP_CONFIGURE 'clr enabled';”. 만일 “config_value”가 “0”이라면, 조치가 필요하지 않다. “CLR” 코드 사용이 필요하고 승인되었는지 여부를 판단하기 위해 시스템 문서를 검토한다. 만일 승인되지 않았다면, 조치가 필요하다. 만일 “CLR” 코드가 필요하고 승인되었다면, “MASTER”에서 다음 스크립트를 사용하여 “UNSAFE” 어셈블리 허가를 확인한다: “SELECT * FROM sys.assemblies WHERE permission_set_desc != 'SAFE' AND is_user_defined = 1;”. 만일 레코드가 리턴되고 “UNSAFE” 어셈블리가 문서화 되지 않고 인가 받지 않았다면, 조치가 필요하다.",
    "Check_sql": [
      "EXEC SP_CONFIGURE 'show advanced options', '1';",
      "RECONFIGURE WITH OVERRIDE;",
      "EXEC SP_CONFIGURE 'clr enabled';",
      "SELECT * FROM sys.assemblies WHERE permission_set_desc != 'SAFE' AND is_user_defined = 1;"
    ],
    "Fix": "인가 받지 않은 CLR 코드를 제거하거나 사용을 비활성화 한다: 다음 쿼리를 실행하여 CLR 사용을 비활성화 한다: “sp_configure 'show advanced options', 1; GO RECONFIGURE; GO sp_configure 'clr enabled', 0; GO RECONFIGURE; GO”. “UNSAFE”나 “EXTERNAL” 허가를 가지고 승인된 “CLR” 코드인 경우, 어셈블리의 허사 세트를 변경하기 위해 “ALTER ASSEMBLY”를 사용하고 인증서가 구성되도록 한다. ",
    "Fix_sql": [
      "sp_configure 'show advanced options', 1;",
      "GO RECONFIGURE;",
      "GO sp_configure 'clr enabled', 0;",
      "GO RECONFIGURE;",
      "GO;",
      "ALTER ASSEMBLY;"
    ]
  },
  {
    "Id": "CDMV-79181",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "비-표준 확장 스토어드 프로시저 접근은 명확하게 필요하고 승인되지 않는 한 제한되거나 비활성화 되어야 한다.",
    "Check": "확장 스토어드 프로시저는 데이터베이스가 종적으로 로딩되고 실행할 수 있는 DLL(Dynamic Link Library)이다. 확장 스토어드 프로시저는 데이터베이스 주소 공간에서 직접적으로 실행하고, 확장 스토어드 프로시저 API를 사용하여 프로그래밍 된다. 비-표준 스토어드 프로시저는 SQL Server 프로세스의 무결성을 훼손할 수 있다. 이 기능은 향후 MS SQL Server 버전에서 제거될 것이다. 신규 개발 작업에서 이 기능을 사용하면 안되고, 가능하면 이런 기능을 사용하는 애플리케이션을 변경한다. 다음 쿼리를 실행하여 비-표준 확장 스토어드 프로시저가 존재하는지 판단한다: “USE [master] GO DECLARE @xplist AS TABLE (xp_name sysname, source_dll nvarchar(255)) INSERT INTO @xplist EXEC sp_helpextendedproc SELECT X.xp_name, X.source_dll, O.is_ms_shipped FROM @xplist X JOIN sys.all_objects O ON X.xp_name = O.name WHERE O.is_ms_shipped = 0 ORDER BY X.xp_name;” 만일 레코드가 리턴 된다면, 비-표준 확장 스토어드 프로시저 사용이 필요하고 승인되는지 여부를 판단하기 위해 시스템 문서를 검토한다. 만일 승인되지 않았다면, 조치가 필요하다. ",
    "Check_sql": [
      "USE [master] GO DECLARE @xplist AS TABLE (xp_name sysname, source_dll nvarchar(255)) INSERT INTO @xplist EXEC sp_helpextendedproc SELECT X.xp_name, X.source_dll, O.is_ms_shipped FROM @xplist X JOIN sys.all_objects O ON X.xp_name = O.name WHERE O.is_ms_shipped = 0 ORDER BY X.xp_name;"
    ],
    "Fix": "문서화 되지 않고 승인되지 않은 비-표준 확장 스토어드 프로시저를 제거한다: “sp_dropextendedproc 'proc name'”.",
    "Fix_sql": [
      "sp_dropextendedproc 'proc name';"
    ]
  },
  {
    "Id": "CDMV-79183",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "연결된 서버 접근이 명확하게 필요하고 승인되지 않는 한 제거되거나 비활성화 되어야 한다.",
    "Check": "연결된 서버를 통하여 OLE DB 데이터 소스에 대하여 분산 이종 쿼리를 접근할 수 있다. 연결된 서버가 생성된 다음에, 분산 쿼리가 이 서버에서 실행될 수 있고, 쿼리가 하나 이상의 데이터 소스로부터 테이블을 조인할 수 있다. 만일 연결된 서버가 데이터베이스로 정의된다면, 원격 스토어드 프로시저가 실행될 수 있다. 다음 명령을 실행하여 연결된 서버 목록을 입수한다: “EXEC sp_linkedservers;”. 연결된 서버 목록이 필요하고 승인되는지 여부를 판단하기 위해 시스템 문서를 검토한다. 만일 승인되지 않았다면, 조치가 필요하다. 연결된 서버 로그인 매핑을 입수하기 위해 다음 쿼리를 실행한다: “SELECT s.name, p.principal_id, l.remote_name FROM sys.servers s JOIN sys.linked_logins l ON s.server_id = l.server_id LEFT JOIN sys.server_principals p ON l.local_principal_id = p.principal_id WHERE s.is_linked = 1”. 연결된 서버 로그인 매핑을 검토하고, sysadmin을 가장할 수 있는 원격 이름을 확인한다. 만일 목록의 로그인이 sysadmin을 가장하고, 시스템 문서에서 요구되지 않는다면, 조치가 필요하다. ",
    "Check_sql": [
      "EXEC sp_linkedservers;",
      "SELECT s.name, p.principal_id, l.remote_name FROM sys.servers s JOIN sys.linked_logins l ON s.server_id = l.server_id LEFT JOIN sys.server_principals p ON l.local_principal_id = p.principal_id WHERE s.is_linked = 1;"
    ],
    "Fix": "인가되지 않은 연결된 서버를 제거하거나 사용을 비활성화 한다. 다음 쿼리를 실행하여 연결된 서버와 모든 관련 로그인을 제거한다: “sp_dropserver 'LinkedServerName', 'droplogins';”. 다음 쿼리를 실행하여 연결된 서버로부터 로그인을 제거한다: “EXEC sp_droplinkedsrvlogin 'LoginName', NULL;”.",
    "Fix_sql": [
      "sp_dropserver 'LinkedServerName', 'droplogins';",
      "EXEC sp_droplinkedsrvlogin 'LoginName', NULL;"
    ]
  },
  {
    "Id": "CDMV-79185",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 PPSM(Ports, Protocols, and Services Management) CAL(Category Assurance List) 및 취약성 평가에 정의된 데로, 조직-정의 프로토콜 사용을 제한/금지하도록 구성되어야 한다. ",
    "Check": "SQL Server가 가능한 프로토콜을 판단하기 위해, SQL Server Configuration Manager를 오픈 한다. 왼쪽 편의 SQL Server Network Configuration을 확장한다. 검토 중인 데이터베이스의 “Protocols for”를 클릭한다. 오른쪽 편의 창이 데이터베이스에 가능한 프로토콜을 보여준다. 만일 Named Pipes가 활성화되고 명확하게 필요하지 않고 인가되지 않는다면, 조치가 필요하다. 만일 리스트 된 프로토콜이 활성화되었지만, 인가되지 않았다면, 조치가 필요하다. ",
    "Check_sql": null,
    "Fix": "SSCM >> SQL Server network Configuration >> Protocols >> 활성화 되었지만 인가 받지 않은 각 프로토콜을 오른쪽-클릭하여 “Disable” 선택.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79187",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 PPSM(Ports, Protocols, and Services Management) CAL(Category Assurance List) 및 취약성 평가에 정의된 데로, 조직-정의 포트 사용을 제한/금지하도록 구성되어야 한다.",
    "Check": "CDMDB가 사용하는 포트에 대하여 SQL Server 구성을 검토한다. SQL Server가 고정 포트나 동적 포트를 사용하도록 구성되었는지 여부를 판단하기 위해, 오른쪽 창의 “TCP/IP” 항목을 더블-클릭하고 “Properties” 다이얼로그를 오픈 한다(디폴트 고정 포크는 “1433”). 만일 이런 것들이 PPMS 지침과 충돌하고, 시스템 문서에서 설명되지 않고 승인되지 않았다면, 조치가 필요하다. ,",
    "Check_sql": null,
    "Fix": "PPS< 지침을 준수하도록SQL Server가 사용하는 포트를 변경하기 위해 SQL Server Configuration을 사용한다. 포트 사용 필요성을 문서화 하고 승인 문서를 입수한다. 더 이상 필요하지 않은 포트는 종료한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79189",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 조직 사용자나 조직 사용자 대신에 동작하는 프로세스를 유일하게 식별하고 인증해야 한다.",
    "Check": "공유 계정이 존재하는지 여부를 판단하기 위해 CDMDB 사용자를 검토한다. 공개 사용 정보를 접근하기 위한 Guest나 공개 계정은 포함되지 않는다. 만일 계정이 공유된다고 판단되면 각각이 개별적으로 인증되었는지 판단한다. 애플리케이션이 표준 공유 계정을 사용하여 CDMDB를 연결할 경우에, 개별 사용자 신원을 식별하고 CDMDB로 전달한다. 만일 각 사용자가 공유 계정을 사용하기 전에 인증되지 않았다면(운영체제나 데이터베이스를 호출하는 애플리케이션에서), 조치가 필요하다. 만일 계정이 공유된다고 판단되고 최종사용자가 직접 접근할 수 있다면, 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "사용자가 접근 가능한 공유 계정을 제거하고 개별 UserID를 사용한다. 공유 계정을 접근하기 전에 개별 인증이 되도록 애플리케이션을 구성한다. 각 사용자 신원은 모든 관련 상황에서 감사 데이터에 수신되고 사용되어야 한다. ",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79191",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "만일 패스워드를 사용하는 CDMDB가 적용된다면, 패스워드 복잡성과 생애주기에 KISA 표준을 적용해야 한다.",
    "Check": "CDMDB 인증을 확인한다. “SELECT CASE SERVERPROPERTY('IsIntegratedSecurityOnly') WHEN 1 THEN 'Windows Authentication' WHEN 0 THEN 'SQL Server Authentication' END as [Authentication Mode];”. 만일 [Authentication Mode]이 “Windows Authentication”이라면, 조치가 필요하지 않다. SQL Server는 운영체제의 패스워드 복잡성과 생애주기 규칙을 계승하여 구성되어야 한다. 다음 쿼리를 실행하여 로그온이 복잡성 설정과 패스워드 생애주기 규칙으로 생성되었는지 검토한다: “SELECT [name], is_expiration_checked, is_policy_checked FROM sys.sql_logins”. 비활성화된 “SA” 계정, “##MS_PolicyTsqlExecutionLogin##” 및 ##MS_PolicyEventProcessingLogin##” 외에 쿼리로 리턴된 계정을 검토한다. 만일 \"is_expiration_checked\" 및 \"is_policy_checked\"가 “1”이면, 조치가 필요하다. 패스워드 복잡성과 관련된 운영체제 설정을 검토한다. 규칙이 강제되는지 여부를 판단하고, 그렇지 않다면, 조치가 필요하다. 패스워드 복잡성에 관해 서버 운영체제를 점검한다. 시작 >> 모든 프로그램 >> 관리자 툴 >> 로컬 보안 정책. 기계의 로컬 정책을 검토한다. 계정 정책 >> 패스워드 정책을 확인한다. ",
    "Check_sql": [
      "SELECT CASE SERVERPROPERTY('IsIntegratedSecurityOnly') WHEN 1 THEN 'Windows Authentication' WHEN 0 THEN 'SQL Server Authentication' END as [Authentication Mode];",
      "SELECT [name], is_expiration_checked, is_policy_checked FROM sys.sql_logins;"
    ],
    "Fix": "보안을 준수하기 위해 SQL Server 운영체제와 SQL Server 로그인을 구성한다. SQL Server가 SQL 로그인에 관하여 운영체제로부터 패스워드 복잡성 규칙을 계승하도록 구성한다. SQL 로그인이 생성 될 때, 정책 및 폐기 점검이 강제되어야 한다: “CREATE LOGIN [] WITH PASSWORD=N'', CHECK_EXPIRATION=ON, CHECK_POLICY=ON;”.",
    "Fix_sql": [
      "CREATE LOGIN [] WITH PASSWORD=N'', CHECK_EXPIRATION=ON, CHECK_POLICY=ON;"
    ]
  },
  {
    "Id": "CDMV-79193",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "로그인이 없는 사용자를 가진 데이터베이스인 컨테인드 데이터베이스는 Windows 보안-주체를 사용해야 한다.",
    "Check": "컨테인드 데이터베이스가 사용되는지 판단하기 위해 다음 쿼리를 실행한다: “SELECT * FROM sys.databases WHERE containment = 1”. 만일 어떤 레코드가 리턴 된다면, 인가된 컨테인드 데이터베이스 사용자 목록에 관해 서버 문서를 확인한다. 컨테인드 데이터베이스 사용자는 SQL 인증을 사용하지 않도록 한다: “EXEC sp_MSforeachdb 'USE [?]; SELECT DB_NAME() AS DatabaseName, * FROM sys.database_principals WHERE authentication_type = 2'” 만일 레코드가 리턴 된다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT * FROM sys.databases WHERE containment = 1;",
      "EXEC sp_MSforeachdb 'USE [?];",
      "SELECT DB_NAME() AS DatabaseName, * FROM sys.database_principals WHERE authentication_type = 2';"
    ],
    "Fix": "Windows 보안-주체로부터 기인한 사용자를 가지도록 SQL Server 컨테인드 데이터베이스를 구성한다. Windows 보안-주체로부터 생성되지 않은 사용자를 제거한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79195",
    "Risk": "H",
    "Status": "Ready",
    "Subject": "만일 패스워드가 인증에 사용된다면, CDMDB는 암호화된 패스워드 표현 만을 전송해야 한다.",
    "Check": "명령으로 \"sqlservermanager13.msc\"를 입력하여 SSCM을 오픈 한다. SSCM >> SQL Server Network Configuration >> 데이터베이스 선택 >> “Protocols” 오른쪽 클릭 >> “Properties” 클릭>> “Flag” 탭 선택. 만일 “Force Encryption”이 “NO”이면, 조치가 필요하다. 만일 “Force Encryption”이 “YES”이면, “Certificate” 탭에서 사용되는 인증서를 확인한다. 만일 KISA-공인 인증서가 아니거나, 인증서가 리스트 되지 않는다면, 조치가 필요하다. 여러 가지 알려진 취약성이 SSL과 초기 TLS 버전에서 보고되었고, 안전한 통신을 지원하기 위해 TLS 1.2를 사용하도록 한다. 만일 SSL이 TLS 1.2를 사용하지 않는다면, 조치가 필요하다. 클러스터된 데이터베이스에서, 인증서는 SSCM에서 보이면 안 된다. 1) “certlm.msc” 명령을 입력하여, 전체-경로 도메인 네임(FQDN, Full Qualified Domain Name) 인증서가 저장된 인증서 스토어를 탐색한다. 2) 화면 오른쪽의 “Personal” 폴더를 확장하고 “Certificates”를 클릭한다. 3) 공인 CA 기관이 발행한 FQDN 이름을 가졌는지 인증서를 검증한다. 인증서를 더블-클릭하고 “Details” 탭을 선택하여 “Thumbprint” 값을 기록한다. 4) “Thumbprint” 필드 값은 regedit을 실행하여 \" HKLM\\SOFTWARE\\MS\\MS SQL Server\\<instance>\\MSSQLServer\\SuperSocketNetLib\\Certificate \"를 찾아서 레지스트리 값과 일치해야 한다. 5) 이 점검은 클러스터의 각 노드에 실행되어야 한다. 만일 어떤 노드가 공인 CA 기관이 발행하지 않은 인증서를 가진다면, 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "KISA-승인 암호화를 사용하여 원격 연결에 인증 데이터를 암호화 하도록 SQL Server를 구성한다. SQL Server Network 연결에 암호법을 적용한다. 명령으로 \"sqlservermanager13.msc\"를 입력하여 SSCM을 오픈 한다. SSCM >> SQL Server Network Configuration >> 데이터베이스 선택 >> “Protocols” 오른쪽-클릭 >> “Properties” 클릭. “Protocols for Properties” 다이얼로그 박스의 “Certificate” 탭 “Certificate” 드롭다운 박스에서 KISA-승인 인증서를 선택하고 “OK” 버튼을 클릭한다. “ForceEncryption” 박스의 “Flags” 탭에서 “Yes”를 선택하고 다이얼로그를 종료하기 위해 “OK” 버튼을 클릭하고, SQL Server를 다시 시작한다. SSL이 TLS 1.2를 사용하지 않는 경우에, 보다 안전한 TLS 1.2로 전환하기 위해 다음 지침을 참조한다. “https://support.MS.com/en-us/kb/3135244” 클러스터된 데이터베이스인 경우, SSCM에서 “Force Encryption”을 “Yes”로 설정한 이후에 인증서를 설치한다. 1) “certlm.msc” 명령을 입력하여, 전체-경로 도메인 네임(FQDN, Full Qualified Domain Name) 인증서가 저장된 인증서 스토어를 탐색한다. 2) 인증서의 “Properties” 페이지의 “Details”탭으로 가서 인증서의 “Thumbprint” 값을 Windows “메모장”으로 복사한다. 3) 메모장의 “Thumbprint” 값의 헥사 문자 간의 빈칸을 제거한다 4) regedit을 실행하고 다음 레지스트리 키 값을 찾아 단계 2의 값을 복사한다: “HKLM\\SOFTWARE\\MS\\MS SQL Server\\<instance>\\MSSQLServer\\SuperSocketNetLib\\Certificate” 5) 만일 SQL 가상 서버가 이 노드에 존재한다면, 클러스터의 다른 노드로 넘기고, 레지스트리가 변경된 노드를 다시 부팅한다. 6) 모든 노드에 이 절차를 반복한다. 상세한 정보는 “https://support.MS.com/en-us/help/316898/how-to-enable-ssl-encryption-for-an-instance-of-sql-server-by-using-mi”를 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79197",
    "Risk": "L",
    "Status": "Ready",
    "Subject": "CDMDB는 사용하고 저장하는 모든 PKI 개인키에 인가된 접근을 강제해야 한다.",
    "Check": "KISA-승인 PKI 알고리즘이 암호, 해싱 및 디지털 서명에 사용되는지 여부를 판단한다. KISA-승인이 아니라면 조치가 필요하다. 상세한 정보는 “https://support.MS.com/en-us/kb/3141890”를 참조하기 바란다.",
    "Check_sql": null,
    "Fix": "KISA-승인 PKI 알고리즘이 암호, 해싱 및 디지털 서명에 사용되도록 CDMDB를 구성한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79199",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 암호화 작업에 KISA-승인 암호화 모듈을 사용해야 한다.",
    "Check": "Windows 관리자 툴에서 Local Security Policy >> Security Options에서 “Security Setting” 컬럼이 “Disabled”라면, 조치가 필요하다. 상세한 정보는 “https://support.MS.com/en-us/kb/955720”를 참조하기 바란다.",
    "Check_sql": null,
    "Fix": "데이터베이스 암호화 작업 시에 KISA-승인 암호화 모듈을 적용한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79201",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 비-조직 사용자와 비-조직 사용자 대신에 동작하는 프로세스를 유일하게 식별하고 인증해야 한다.",
    "Check": "비-조직 사용자가 시스템에 로그인할 때 개별적으로 식별되고 인증되는지 판단하기 위해 시스템 문서, SQL Server 설정 및 인증 시스템 설정을 검토한다. SQL Server에 로그인 목록을 입수하고 모든 계정이 유일하게 식별되도록 다음 쿼리를 실행한다: “SELECT name, type_desc FROM sys.server_principals WHERE type in ('S','U')”. 만일 계정이 공유된다고 판단되면, 각각이 개별적으로 인증되는지 판단한다. 애플리케이션이 표준 공유 계정을 사용하여 SQL Server를 연결할 경우에, 개별 사용자 식별을 수집하고 SQL Server에 전달해야 한다. 만일 문서에서 개별 인증이 필요 없는 공개 읽기-전용(공개 사용자 관점으로) 데이터베이스라고 명시다면, 조치가 필요하지 않다. 만일 비-조직 사용자가 유일하게 식별되지 않고 인증되지 않는다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT name, type_desc FROM sys.server_principals WHERE type in ('S','U');"
    ],
    "Fix": "모든 로그인은 시스템에 로그인 하는 모든 비-조직 사용자를 유일하게 식별하고 인증해야 한다. 개별 계정을 매핑하는 SQL Server와 유일 계정을 가진 운영체제 조합을 통하여 수행될 수 있다. 계정이 문서화 되고 유일하도록 서버 문서를 확인한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79203",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 세션 ID를 추정하는 중간자 공격을 대응하여 보호하기 위해 통신 세션의 진본성을 유지 관리해야 한다.",
    "Check": "Windows가 KISA-승인 암호화, 해싱 및 디지털 서명 알고리즘을 사용하는지 확인한다. KISA-승인이 아니라면 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "Windows가 KISA-승인 암호화, 해싱 및 디지털 서명 알고리즘을 사용하도록 구성한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79205",
    "Risk": "H",
    "Status": "Ready",
    "Subject": "CDMDB는 모든 휴지기 정보의 기밀성과 무결성을 보호해야 한다.",
    "Check": "시스템이 기밀-분류 정보를 처리하는지 여부를 판단하기 위해 시스템 문서를 검토한다. 만일 시스템이 기밀-분류 정보를 처리하지 않는다면, 심각도는 “M”으로 설정된다. 만일 애플리케이션 소유자와 인가 담당자가 휴지기 데이터의 암호화가 필요하다고 판단한다면, 2 차 장치의 데이터가 암호화 되어야 한다. 만일 전체-디스크 암호화가 사용된다면, 조치가 필요하지 않다. 만일 데이터 암호화가 필요하다면, 데이터가 실행하기 위해 2차 장치에 이동하기 전에 암호화 되어야 한다: “SELECT d.name AS [Database Name], CASE e.encryption_state WHEN 0 THEN 'No database encryption key present, no encryption' WHEN 1 THEN 'Unencrypted' WHEN 2 THEN 'Encryption in progress' WHEN 3 THEN 'Encrypted' WHEN 4 THEN 'Key change in progress' WHEN 5 THEN 'Decryption in progress' WHEN 6 THEN 'Protection change in progress' END AS [Encryption State] FROM sys.dm_database_encryption_keys e RIGHT JOIN sys.databases d ON DB_NAME(e.database_id) = d.name WHERE d.name NOT IN ('master','model','msdb') ORDER BY [Database Name];”. 암호화가 필요한 각 사용자 데이터베이스에서, 암호화가 시행 중인지 확인한다. 만일 그렇지 않다면, 조치가 필요하다. 데이터베이스의 데이터 기밀 수준에 적합한 물리적 보안 대책, 운영체제 접근 통제 목록 및 조직 통제가 존재하는지 확인한다. 만일 그렇지 않다면, 조치가 필요하다.  ",
    "Check_sql": [
      "SELECT d.name AS [Database Name], CASE e.encryption_state WHEN 0 THEN 'No database encryption key present, no encryption' WHEN 1 THEN 'Unencrypted' WHEN 2 THEN 'Encryption in progress' WHEN 3 THEN 'Encrypted' WHEN 4 THEN 'Key change in progress' WHEN 5 THEN 'Decryption in progress' WHEN 6 THEN 'Protection change in progress' END AS [Encryption State] FROM sys.dm_database_encryption_keys e RIGHT JOIN sys.databases d ON DB_NAME(e.database_id) = d.name WHERE d.name NOT IN ('master','model','msdb') ORDER BY [Database Name];"
    ],
    "Fix": "2차 장치의 데이터 기밀성과 무결성을 보호하기 위해 적절한 통제를 적용한다. 암호화가 필요하다면, 전체-디스크 암호나 데이터베이스 암호로 수행될 수 있다. 데이터베이스 암호화를 활성화 하기 위해,, 마스터 키를 생성하고, 데이터베이스 암호 키를 생성하며, 마스터 키와 밀착한 메커니즘을 사용하여 보호하고, 암호화를 설정한다. 데이터베이스의 데이터 기밀 수준에 적합한 물리적 보안 대책, 운영체제 접근 통제 목록 및 조직 통제를 구현한다. ",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79207",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "서비스 마스터 키는 백업되고 오프라인과 외부 사이트에 저장되어야 한다.",
    "Check": "시스템 보안 계획(SSP)에서 서버 서비스 마스터 키의 절차, 백업 증거를 검토한다. 만일 절차나 증거가 존재하지 않는다면, 조치가 필요하다. 만일 절차가 서비스 마스터 키의 오프라인이나 외부 사이트 저장소를 명시하지 않는다면, 조치가 필요하다. 만일 절차가 서비스 마스터 키 백업의 접근 제한을 명시하지 않는다면, 조치가 필요하다. ",
    "Check_sql": null,
    "Fix": "서비스 마스터 키를 안전하게 백업하고 저장하는 절차를 구현하고 문서화 해야 한다. 서비스 마스터 키의 백업/저장소, 제한된 접근/복구의 증거를 설정하는 절차 방법을 포함하고, 외부 사이트에 키를 저장하는 방법을 포함해야 한다: “BACKUP SERVICE MASTER KEY TO FILE = 'path_to_file' ENCRYPTION BY PASSWORD = 'password';”. 패스워드가 필요하기 때문에, 비인가 직원에게 노출되지 않고 평문으로 저장되지 않도록 주의한다.  ",
    "Fix_sql": [
      "BACKUP SERVICE MASTER KEY TO FILE = 'path_to_file' ENCRYPTION BY PASSWORD = 'password';"
    ]
  },
  {
    "Id": "CDMV-79209",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "마스터 키는 백업되고 오프라인과 외부 사이트에 저장되어야 한다.",
    "Check": "만일 애플리케이션 소유자나 인가 담당자가 휴지기 데이터의 암호화가 필요하지 않다고 판단한다면, 조치가 필요하지 않다. 시스템 보안 계획(SSP)에서 마스터 키의 절차와 백업 증거를 검토한다. 만일 절차나 증거가 존재하지 않는다면 조치가 필요하다. 만일 절차가 마스터 키의 오프라인이나 외부 사이트 저장소를 명시하지 않는다면, 조치가 필요하다. 만일 절차가 마스터 키 백업의 접근 제한을 명시하지 않는다면, 조치가 필요하다.  ",
    "Check_sql": null,
    "Fix": "마스터 키를 안전하게 백업하고 저장하는 절차를 구현하고 문서화 해야 한다. 마스터 키의 백업/저장소, 제한된 접근/복구의 증거를 설정하는 절차 방법을 포함하고, 외부 사이트에 키를 저장하는 방법을 포함해야 한다: “BACKUP SERVICE MASTER KEY TO FILE = 'path_to_file' ENCRYPTION BY PASSWORD = 'password';”. 패스워드가 필요하기 때문에, 비인가 직원에게 노출되지 않고 평문으로 저장되지 않도록 주의한다.",
    "Fix_sql": [
      "BACKUP SERVICE MASTER KEY TO FILE = 'path_to_file' ENCRYPTION BY PASSWORD = 'password';"
    ]
  },
  {
    "Id": "CDMV-79211",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 공유 시스템 자원을 통한 비인가/비의도 정보 전송을 금지해야 한다(공통 평가 기준 - CC).",
    "Check": "공통 평가 기준(CC, Common Criteria) 준수가 시스템 성능에 미치는 잠재적 영향 때문에 요구되지 않는지 판단하기 위해 시스템 문서를 검토한다. SQL Server 잔존 정보 보호(RIP, Residual Information Protection)는 메모리에 신규 자원이 재할당되기 전에 알려진 비트 패턴으로 겹쳐 쓰는 메모리 할당이 필요하다. RIP 표준에 맞추면 보안을 개선할 수 있지만, 메모리 할당 겹쳐 쓰기는 성능 저하를 유발한다. 공통 평가 기준(CC) 준수 활성화 옵션이 활성화 된 다음에, 겹쳐 쓰기가 발생한다. 데이터베이스 구성을 검토한다: “SELECT name, value_in_use FROM sys.configurations WHERE name = 'common criteria compliance enabled' and value_in_use = 0;”. 만일 레코드가 리턴되지 않고 예외 사항이 시스템 문서에 정의되지 않는다면, 조치가 필요하다. 주: 이 기능을 활성화 하면 고-성능 데이터베이스의 성능에 영향을 끼칠 수도 있다. 만일 성능에 많은 영향을 준다면, 비활성화시킬 수도 있다. ",
    "Check_sql": [
      "SELECT name, value_in_use FROM sys.configurations WHERE name = 'common criteria compliance enabled' and value_in_use = 0;"
    ],
    "Fix": "다른 사용자/프로세스의 비인가 접근으로부터 한 프로세스/사용자의 자원을 효율적으로 보호하기 위해 SQL Server를 구성한다: “sp_configure 'show advanced options', 1; GO RECONFIGURE; GO sp_configure 'common criteria compliance enabled', 1; GO RECONFIGURE GO”.",
    "Fix_sql": [
      "sp_configure 'show advanced options', 1;",
      "GO RECONFIGURE;",
      "GO sp_configure 'common criteria compliance enabled', 1;",
      "GO RECONFIGURE GO;"
    ]
  },
  {
    "Id": "CDMV-79213",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 공유 시스템 자원을 통한 비인가/비의도 정보 전송을 금지해야 한다(즉시 파일 초기화 - IFI).",
    "Check": "즉시 파일 초기화(IFI, Instant File Initialization)가 필요한지 판단하기 위해 시스템 문서를 검토한다. 만일 IFI가 필요한대로 문서화 되었다면, 조치가 필요하지 않다. IFI 지원이 활성화 되었는지(SQL Server 2016에서 디폴트) 여부를 판단하기 위해 시스템 구성을 검토한다. 시작 >> 제어판 >> 관리자 툴 >> 로컬 보안 정책 >> 로컬 정책 >> 사용자 권한 배정. 만일 “SQL Service SID(디폴트 인스턴스: NT SERVICE\\MSSQLSERVER, 네임드 인스턴스: NT SERVICE\\MSSQL$InstanceName)”가 “Perform volume maintenance tasks” Local Rights Assignment로 허용되고, 시스템 문서에 문서화 되지 않았다면, 조치가 필요하다. ",
    "Check_sql": null,
    "Fix": "만일 IFI가 필요하지만 문서화 되지 않았다면, “Perform volume maintenance tasks” Local Rights Assignment로부터 SQL Service SID와 서비스 계정을 제거하여 데이터베이스의 즉시 파일 초기화를 비활성화 한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79215",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "데이터베이스 파일 접근은 관련 프로세스, 인가된 관리 사용자로 제한되어야 한다.",
    "Check": "운영체제, 데이터베이스 파일 시스템, 데이터베이스 로그 파일 및 데이터베이스 백업 파일에 의해 사용자에게 허용된 허가를 검토한다. SQL Server 데이터, 트랜잭션 로그 및 백업 파일의 위치를 입수하기 위해, \"Get SQL Data and Backup Directories.sql\" 파일을 오픈하고 실행한다. 위 스크립트에서 리턴된 각 디렉터리에서, 정확한 허가가 적용되었는지 확인한다. Windows 탐색기 >> 폴더 탐색 >> 폴더를 클릭 >> “Properties” 클릭 >> “Security” 탭 탐색 >> 보안-주체 및 허가 목록을 검토: “Database Administrators ALL Full Control, SQL Server Service SID       Data; Log; Backup; Full Control, SQL Server Agent Service SID Backup                Full Control, SYSTEM ALL Full Control, CREATOR OWNER ALL                   Full Control”. “Service SID”에 관한 상세한 정보는 “https://aka.ms/sql-service-sids”를 참조하기 바란다. SQL Server에 관한 전체 디렉터리 허가 및 운영체제 권한을 포함하여 모든 허가 요구사항은 “https://aka.ms/sqlservicepermissions”를 참조하기 바란다. 만일 추가 허가가 허용되었지만 인가된 대로 문서화 되지 않았다면, 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "SQL Server 데이터, 로그 및 백업 디렉터리로부터 비인가된 허가를 제거한다. “Security” 탭 >> 사용자 항목 선택 >> “Remove” 클릭.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79217",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 정보시스템보안담당자/정보시스템보안관리자/시스템관리자/데이터베이스관리자(ISSO/ISSM/SA/DBA)에게만 상세 에러 메시지를 노출해야 한다.",
    "Check": "애플리케이션과 커스텀 데이터베이스 코드(스토어드 프로시저, 트리거) 내의 에러 메시지는 지침에 강제되고 코드 검토가 시행되어야 한다. SQL Server는 SQL Server 에러 로그에 특정 시스템 이벤트 및 사용자-정의 이벤트를 생성한다. SQL Server 에러 로그는 SQL Server Management Studio GUI를 사용하여 조회될 수 있다. 시스템 관리자나 sysadmin 수준 허가가 허용된 모든 사용자는 로그를 조회할 수 잇다. 다음 스크립트로 리턴된 사용자를 검토한다: “USE master GO SELECT Name FROM syslogins WHERE (sysadmin = 1 or securityadmin = 1) and hasaccess = 1;”. 만일 비인가 사용자가 Program Files\\MS SQL Server\\MSSQL.n\\MSSQL\\LOG에 위치한 SQL Server Error Log를 접근한다면, 조치가 필요하다. 추가적으로, SQL Server Error Log는 Program Files\\MS SQL Server\\MSSQL.n\\MSSQL\\LOG\\에 위치할 수도 있다. 인가된 사용자 만이 리스트 되도록 이 폴더의 허가를 검토한다. 만일 비인가 사용자가 SQL Server Management Studio의 SQL Server Error Log를 접근한다면, 조치가 필요하다.",
    "Check_sql": [
      "USE master GO SELECT Name FROM syslogins WHERE (sysadmin = 1 or securityadmin = 1) and hasaccess = 1;"
    ],
    "Fix": "인가된 직원이 검토하기 위해, SQL Server가 생성한 상세 에러 메시지를 기록하기 위해 데이터베이스나 애플리케이션의 감사 로깅, 트레이싱 및 커스텀 코드를 구성한다. 만일 비인가 사용자가 SQL Server Management Studio의 SQL Server Error Log를 접근한다면, 보안 관리자나 sysadmin 역할로부터 제거하기 위해 REVOKE/DENY 명령을 사용한다. 만일 비인가 사용자가 Program Files\\MS SQL Server\\MSSQL.n\\MSSQL\\LOG의 SQL Server Error Log를 접근한다면, 허기를 제거한다. 비-관리 사용자에게 리턴되는 특정 시스템-수준 에러 정보를 표시하기 위해 트레이스 플래그 3625를 활성화 한다: SSCM >> SQL Services 클릭 >> 데이터베이스 속성 오픈 >> “Service parameters” 탭 클릭 >> “-T3625” 입력 >> “Add” 클릭 >> “OK” 클릭 >> 데이터베이스 재시작.",
    "Fix_sql": [
      "REVOKE/DENY 명령을 사용한다. 만일 비인가 사용자가 Program Files\\MS SQL Server\\MSSQL.n\\MSSQL\\LOG의 SQL Server Error Log를 접근한다면, 허기를 제거한다. 비-관리 사용자에게 리턴되는 특정 시스템-수준 에러 정보를 표시하기 위해 트레이스 플래그 3625를 활성화 한다: SSCM >> SQL Services 클릭 >> 데이터베이스 속성 오픈 >> “Service parameters;"
    ]
  },
  {
    "Id": "CDMV-79219",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 구현된 보안 대책/안전장치의 비활성화/회피/변경을 포함하여 비-권한 사용자의 특권 기능 실행을 금지해야 한다.",
    "Check": "인가된 사용자 만이 접근 권한을 가지고 서버-수준 오브젝트를 생성하고 허가가 허용되도록 서버-수준 보안-개체와 빌트인 역할 멤버십을 검토한다. 로그인 유형별로 DBMS 서버 보안-개체의 필요 보호 수준을 판단하기 위해 시스템 문서를 검토한다. 서버의 허가가 적절한지 검토한다. 만일 실제 허가가 문서화된 요구사항과 일치하지 않다면, 조치가 필요하다. 로그인/역할에 배정된 모든 허가 목록을 입수한다: “SELECT DISTINCT CASE WHEN SP.class_desc IS NOT NULL THEN CASE WHEN SP.class_desc = 'SERVER' AND S.is_linked = 0 THEN 'SERVER' WHEN SP.class_desc = 'SERVER' AND S.is_linked = 1 THEN 'SERVER (linked)' ELSE SP.class_desc END WHEN E.name IS NOT NULL THEN 'ENDPOINT'         WHEN S.name IS NOT NULL AND S.is_linked = 0 THEN 'SERVER' WHEN S.name IS NOT NULL AND S.is_linked = 1 THEN 'SERVER (linked)' WHEN P.name IS NOT NULL THEN 'SERVER_PRINCIPAL' ELSE '???' END AS [Securable Class],    CASE WHEN E.name IS NOT NULL THEN E.name WHEN S.name IS NOT NULL THEN S.name WHEN P.name IS NOT NULL THEN P.name ELSE '???' END                    AS [Securable], P1.name AS [Grantee], P1.type_desc AS [Grantee Type],  sp.permission_name AS [Permission], sp.state_desc AS [State], P2.name AS [Grantor], P2.type_desc AS [Grantor Type] FROM sys.server_permissions SP INNER JOIN sys.server_principals P1 ON P1.principal_id = SP.grantee_principal_id INNER JOIN sys.server_principals P2 ON P2.principal_id = SP.grantor_principal_id FULL OUTER JOIN sys.servers S ON SP.class_desc = 'SERVER' AND S.server_id = SP.major_id FULL OUTER JOIN sys.endpoints E ON SP.class_desc = 'ENDPOINT' AND E.endpoint_id = SP.major_id FULL OUTER JOIN sys.server_principals P ON  SP.class_desc = 'SERVER_PRINCIPAL' AND P.principal_id = SP.major_id;”. 모든 서버 역할 멤버십을 입수한다: “SELECT R.name AS [Role], M.name AS [Member] FROM sys.server_role_members X INNER JOIN sys.server_principals R ON R.principal_id = X.role_principal_id INNER JOIN sys.server_principals M ON M.principal_id = X.member_principal_id;”. CONTROL SERVER 허가는 유사하지만, sysadmin 고정 서버 역할과는 동일하지 않다. 허가가 역할 멤버십을 의미하지 않고, 역할 멤버십이 허가를 허용하지 않는다(예, CONTROL SERVER는 sysadmin 고정 서버 역할에 멤버십을 의미하지 않음). 문서화되고 승인된 로그인 마니 SQL Server 에서 특권 기능을 가지도록 한다. 만일 현재 구성이 문서화된 기준과 일치하지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT DISTINCT CASE WHEN SP.class_desc IS NOT NULL THEN CASE WHEN SP.class_desc = 'SERVER' AND S.is_linked = 0 THEN 'SERVER' WHEN SP.class_desc = 'SERVER' AND S.is_linked = 1 THEN 'SERVER (linked)' ELSE SP.class_desc END WHEN E.name IS NOT NULL THEN 'ENDPOINT'         WHEN S.name IS NOT NULL AND S.is_linked = 0 THEN 'SERVER' WHEN S.name IS NOT NULL AND S.is_linked = 1 THEN 'SERVER (linked)' WHEN P.name IS NOT NULL THEN 'SERVER_PRINCIPAL' ELSE '???' END AS [Securable Class],    CASE WHEN E.name IS NOT NULL THEN E.name WHEN S.name IS NOT NULL THEN S.name WHEN P.name IS NOT NULL THEN P.name ELSE '???' END                    AS [Securable], P1.name AS [Grantee], P1.type_desc AS [Grantee Type],  sp.permission_name AS [Permission], sp.state_desc AS [State], P2.name AS [Grantor], P2.type_desc AS [Grantor Type] FROM sys.server_permissions SP INNER JOIN sys.server_principals P1 ON P1.principal_id = SP.grantee_principal_id INNER JOIN sys.server_principals P2 ON P2.principal_id = SP.grantor_principal_id FULL OUTER JOIN sys.servers S ON SP.class_desc = 'SERVER' AND S.server_id = SP.major_id FULL OUTER JOIN sys.endpoints E ON SP.class_desc = 'ENDPOINT' AND E.endpoint_id = SP.major_id FULL OUTER JOIN sys.server_principals P ON  SP.class_desc = 'SERVER_PRINCIPAL' AND P.principal_id = SP.major_id;",
      "SELECT R.name AS [Role], M.name AS [Member] FROM sys.server_role_members X INNER JOIN sys.server_principals R ON R.principal_id = X.role_principal_id INNER JOIN sys.server_principals M ON M.principal_id = X.member_principal_id;"
    ],
    "Fix": "인가된 사용자에게만 서버-수준 보안-개체에 허가를 허용하도록 제한한다. 특히 sysadmin, 보안 관리자 빌트인 데이터베이스-수준 역할, CONTROL SERVER 허가 및 GRANT 허가로 GRANT 사용이 해당된다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79221",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "인증서 및 프록시는 필요한 경우로만 제한되어야 한다.",
    "Check": "외부 프로세스를 실행하는데 사용되는 계정 목록을 입수하기 위해 서버 문서를 검토한다. 외부 프로세스에서 사용하도록 현재 구성된 계정 목록을 입수하기 위해 다음 쿼리를 실행한다: “SELECT C.name AS credential_name, C.credential_identity FROM sys.credentials C GO SELECT P.name AS proxy_name, C.name AS credential_name, C.credential_identity FROM sys.credentials C JOIN msdb.dbo.sysproxies P ON C.credential_id = P.credential_id WHERE P.enabled = 1 GO”. 만일 문서화 되지 않고 인가되지 않은 인증서나 SQL 에이전트 프록시 계정이 리턴 된다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT C.name AS credential_name, C.credential_identity FROM sys.credentials C GO SELECT P.name AS proxy_name, C.name AS credential_name, C.credential_identity FROM sys.credentials C JOIN msdb.dbo.sysproxies P ON C.credential_id = P.credential_id WHERE P.enabled = 1 GO;"
    ],
    "Fix": "인가되지 않은 인증서나 SQL 에이전트 프록시 계정을 제거한다: “DROP CREDENTIAL <Credential Name> GO USE [msdb] EXEC sp_delete_proxy @proxy_name = '<Proxy Name>' GO”.",
    "Fix_sql": [
      "DROP CREDENTIAL <Credential Name> GO USE [msdb] EXEC sp_delete_proxy @proxy_name = '<Proxy Name>' GO;"
    ]
  },
  {
    "Id": "CDMV-79223",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 모든 SQL Server 컴포넌트에서 생성한 감사 레코드에서 추출된 내용을 중앙집중 관리해야 한다.",
    "Check": "감사 레코드가 외부 저장되는 방법 및 로컬 감사 로그 공간이 관리되는 방법에 관해 시스템 문서를 검토한다. 만일 SQL Server 감사 레코드가 중앙집중 로그 관리 시스템에 직접적으로 쓰여지거나 체계적으로 전송되지 않는다면, 조치가 필요하다. ",
    "Check_sql": null,
    "Fix": "SQL Server 감사 레코드가 중앙집중 로그 관리 시스템에 직접적으로 쓰여지고 체계적으로 전송되도록 소프트웨어 툴을 구성하고 적용한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79225",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 모든 SQL Server 컴포넌트에서 생성한 감사 레코드에서 추출된 내용을 중앙집중 구성해야 한다.",
    "Check": "감사 레코드가 외부 저장되는 방법 및 로컬 감사 로그 공간이 관리되는 방법에 관해 시스템 문서를 검토한다. 만일 감사 목적으로 사용되는 트레이스를 포함하여 SQL Server 감사 레코드가 중앙집중 로그 관리 시스템에 직접적으로 쓰여지거나 체계적으로 전송되지 않는다면, 조치가 필요하다. ",
    "Check_sql": null,
    "Fix": "감사 목적으로 사용되는 트레이스를 포함하여 SQL Server 감사 레코드가 중앙집중 로그 관리 시스템에 직접적으로 쓰여지고 체계적으로 전송되도록 소프트웨어 툴을 구성하고 적용한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79227",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 조직-정의 감사 레코드 스토리지 요구사항에 따라 감사 레코드 스토리지 용량을 배정해야 한다.",
    "Check": "SQL 감사 파일 크기 구성에 관해 서버 문서를 검토한다. 감사 파일 경로와 드라이브를 탐색한다: “SELECT max_file_size, max_rollover_files, log_file_path AS \"Audit Path\" FROM sys.server_file_audits;”. SQL Audit File 속성으로부터 최대 파일 크기 및 파일 개수에 필요한 공간을 계산한다. 만일 “max_file_size”와 “max_rollover_files”를 곱한 합이 스토리지 크기를 넘어가거나, “max_file_size”나 “max_rollover_files”가 “0”(무제한)으로 설정되었다면, 조치가 필요하다.  ",
    "Check_sql": [
      "SELECT max_file_size, max_rollover_files, log_file_path AS \"Audit Path\" FROM sys.server_file_audits;"
    ],
    "Fix": "대상 파일이 쓰여질 수 있는 모든 파일의 최대 총 크기를 수용하도록 충분한 공간을 가지도록 SQL 감사 파일 배치를 검토한다. 시스템이 지원 가능한 크기의 로그 개수 이내로 유지되며 생성되는 감사 로그 파일의 최대 개수로 구성한다. 정확한 파일 개수가 정의되도록 감사의 “max_files” 파라미터를 갱신한다. ",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79229",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 배정된 감사 레코드 스토리지 볼륨이 최대 감사 레코드의 75%에 도달할 때 적절한 지원 담당 직원에게 경보를 제공해야 한다.",
    "Check": "운영체제 및 SQL Server는 드라이브나 볼륨 유휴 공간을 점검하는 여러 가지 방법을 제공한다. SQL 감사가 저장되는 대상 드라이브를 배치하고 시스템 구성을 검토한다. 만일 SQL 감사 드라이브가 75%에 도달할 때 지원 담당 직원에게 통지하는 경보가 존재하지 않는다면, 조치가 필요하다. ",
    "Check_sql": null,
    "Fix": "스토리지 볼륨 활용이 75%에 도달할 때 즉시적으로 적절한 지원 담당 직원에게 통지하도록 시스템을 구성하기 위해, 운영체제 경보 메커니즘, SQL 에이전트, 운용 관리 툴 및 제3자 툴을 사용한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79231",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 실시간 경보가 필요한 모든 감사 실패 시에 적절한 지원 담당 직원에게 즉시적 실시간 경보를 제공해야 한다.",
    "Check": "감사 실패 이벤트가 실시간 경보가 필요한지 판단하기 위해 시스템 문서를 검토한다. SQL Server 설정과 코드를 검토한다. 만일 문서에 명시된 실시간 경보가 비활성화이면, 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "명시된 감사 이벤트 실패가 발생할 때 적절한 지원 담당 직원에게 즉시적 실시간 경보를 제공하도록 시스템을 구성한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79233",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 감사 레코드와 애플리케이션 데이터에 협정세계표준시(UTC)에 매핑될 수 있는 타임스탬프를 기록해야 한다.",
    "Check": "SQL Server 감사는 UTC 시간으로 타임스탬프를 저장한다. 컴퓨터가 도메인과 결합되는지 판단한다: “SELECT DEFAULT_DOMAIN()[DomainName]” 만일 “NULL”이 아니라면, 조치가 필요하지 않다. 만일 컴퓨터가 도메인에 결합되지 않는다면, 시간 출처가 무엇인지 판단한다. PowerShell 세션에서 다음 명령을 실행한다: “w32tm /query /source”. 만일 명령 결과가 “Local CMOS Clock”이고 인가 담당자(AO, Authorized Officer)의 인가와 정의로 문서화되지 않았다면, 조치가 필요하다. 만일 운영체제가 타임 서버와 동기화 하지 않는다면, 시스템의 정확한 시간을 유지 관리하는 절차를 검토한다. 만일 이런 절차가 존재하지 않는다면, 조치가 필요하다. 만일 절차가 존재한다면, 정확한 시간이 실제로 유지 관리되는 증거를 검토한다. 만일 증거가 다르다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT DEFAULT_DOMAIN()[DomainName];"
    ],
    "Fix": "가능하다면, NTP(Network Time Protocol)를 사용하는 공식 타임 서버와 자동적으로 동기화 하도록 운영체제를 구성한다. NTP(Network Time Protocol)를 사용하는 공식 타임 서버와 자동적으로 동기화를 구현하지 못하는 이유가 있다면, 정확한 시간을 유지 관리하는 절차와 근거를 문서화 하고 인가 담당자의 인가를 받고 절차를 집행한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79235",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 데이터베이스 구성 변경과 관련된 접근 제한(비인가 허가)을 강제해야 한다.",
    "Check": "SQL Server에 특권 허가와 역할 멤버십을 가진 로그인 목록을 입수한다. 해당 허가 배정과 로그인/역할 목록을 입수하기 위해 다음 쿼리를 실행한다: “SELECT p.name AS Principal, p.type_desc AS Type, sp.permission_name AS Permission, sp.state_desc AS State FROM sys.server_principals p INNER JOIN sys.server_permissions sp ON p.principal_id = sp.grantee_principal_id WHERE sp.permission_name = 'CONTROL SERVER' OR sp.state = 'W';”. 로그인/역할 멤버십 목록을 입수하기 위해 다음 쿼리를 실행한다: “SELECT m.name AS Member, m.type_desc AS Type, r.name AS Role FROM sys.server_principals m INNER JOIN sys.server_role_members rm ON m.principal_id = rm.member_principal_id INNER JOIN sys.server_principals r ON rm.role_principal_id = r.principal_id WHERE r.name IN ('sysadmin','securityadmin','serveradmin');”. 리턴된 로그인/역할이 인가되었는지 검증하기 서버 문서를 확인한다. 만일 로그인/역할이 문서화 되지 않고 인가되지 않았다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT p.name AS Principal, p.type_desc AS Type, sp.permission_name AS Permission, sp.state_desc AS State FROM sys.server_principals p INNER JOIN sys.server_permissions sp ON p.principal_id = sp.grantee_principal_id WHERE sp.permission_name = 'CONTROL SERVER' OR sp.state = 'W';",
      "SELECT m.name AS Member, m.type_desc AS Type, r.name AS Role FROM sys.server_principals m INNER JOIN sys.server_role_members rm ON m.principal_id = rm.member_principal_id INNER JOIN sys.server_principals r ON rm.role_principal_id = r.principal_id WHERE r.name IN ('sysadmin','securityadmin','serveradmin');"
    ],
    "Fix": "보안-주체로부터 비인가 허가를 철회한다. “https://msdn.MS.com/en-us/library/ms186308.aspx”를 참조하기 바란다. 역할로부터 비인가 로그인을 제거한다: “ALTER SERVER ROLE DROP MEMBER login;”. “https://technet.MS.com/en-us/library/ee677634.aspx”를 참조하기 바란다.",
    "Fix_sql": [
      "ALTER SERVER ROLE DROP MEMBER login;"
    ]
  },
  {
    "Id": "CDMV-79237",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "Windows는 데이터베이스 구성 변경과 관련된 접근 제한을 강제해야 한다.",
    "Check": "로컬 관리자 그룹을 통하여 서버에 특권 접근을 가진 사용자 목록을 입수한다: “lusrmgr.msc” 실행 >> “Groups” 선택 >> “Administrators” 더블-클릭” 다른 방법으로 PowerShell에서 다음 명령을 실행한다: “net localgroup administrators”. 리턴된 사용자가 인가되었는지 검증하기 위해 서버 문서를 확인한다. 만일 사용자가 문서화 되지 않고 인가되지 않았다면, 조치가 필요하다. ",
    "Check_sql": null,
    "Fix": "인가되지 않은 로컬 관리자 그룹에서 사용자를 제거한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79239",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 데이터베이스 구성 변경과 관련된 접근 제한 강제의 감사 레코드를 생성해야 한다.",
    "Check": "다음 쿼리를 실행하여 감사가 거부된 동작을 추출하기 위해 구성되었는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. 다음 이벤트가 서버 감사 명세에 포함되었는지 검증하기 위해 다음 쿼리를 실행한다: “APPLICATION_ROLE_CHANGE_PASSWORD_GROUP, AUDIT_CHANGE_GROUP, BACKUP_RESTORE_GROUP, DATABASE_CHANGE_GROUP, DATABASE_OBJECT_ACCESS_GROUP, DATABASE_OBJECT_CHANGE_GROUP, DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP, DATABASE_OBJECT_PERMISSION_CHANGE_GROUP, DATABASE_OWNERSHIP_CHANGE_GROUP, DATABASE_OPERATION_GROUP, DATABASE_OWNERSHIP_CHANGE_GROUP, DATABASE_PERMISSION_CHANGE_GROUP, DATABASE_PRINCIPAL_CHANGE_GROUP, DATABASE_PRINCIPAL_IMPERSONATION_GROUP, DATABASE_ROLE_MEMBER_CHANGE_GROUP, DBCC_GROUP, LOGIN_CHANGE_PASSWORD_GROUP, SCHEMA_OBJECT_CHANGE_GROUP, SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP, SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP, SERVER_OBJECT_CHANGE_GROUP, SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP, SERVER_OBJECT_PERMISSION_CHANGE_GROUP, SERVER_OPERATION_GROUP, SERVER_PERMISSION_CHANGE_GROUP, SERVER_PRINCIPAL_IMPERSONATION_GROUP, SERVER_ROLE_MEMBER_CHANGE_GROUP, SERVER_STATE_CHANGE_GROUP, TRACE_CHANGE_GROUP”, “SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name IN ('APPLICATION_ROLE_CHANGE_PASSWORD_GROUP', 'AUDIT_CHANGE_GROUP', 'BACKUP_RESTORE_GROUP', 'DATABASE_CHANGE_GROUP', 'DATABASE_OBJECT_ACCESS_GROUP', 'DATABASE_OBJECT_CHANGE_GROUP', 'DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP', 'DATABASE_OBJECT_PERMISSION_CHANGE_GROUP', 'DATABASE_OWNERSHIP_CHANGE_GROUP', 'DATABASE_OPERATION_GROUP', 'DATABASE_OWNERSHIP_CHANGE_GROUP', 'DATABASE_PERMISSION_CHANGE_GROUP', 'DATABASE_PRINCIPAL_CHANGE_GROUP', 'DATABASE_PRINCIPAL_IMPERSONATION_GROUP', 'DATABASE_ROLE_MEMBER_CHANGE_GROUP', 'DBCC_GROUP', 'LOGIN_CHANGE_PASSWORD_GROUP', 'SCHEMA_OBJECT_CHANGE_GROUP', 'SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP', 'SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP', 'SERVER_OBJECT_CHANGE_GROUP', 'SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP', 'SERVER_OBJECT_PERMISSION_CHANGE_GROUP', 'SERVER_OPERATION_GROUP', 'SERVER_PERMISSION_CHANGE_GROUP', 'SERVER_PRINCIPAL_IMPERSONATION_GROUP', 'SERVER_ROLE_MEMBER_CHANGE_GROUP', 'SERVER_STATE_CHANGE_GROUP') Order by d.audit_action_name;”. 만일 식별된 그룹이 리턴되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "BACKUP_RESTORE_GROUP, DATABASE_CHANGE_GROUP, DATABASE_OBJECT_ACCESS_GROUP, DATABASE_OBJECT_CHANGE_GROUP, DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP, DATABASE_OBJECT_PERMISSION_CHANGE_GROUP, DATABASE_OWNERSHIP_CHANGE_GROUP, DATABASE_OPERATION_GROUP, DATABASE_OWNERSHIP_CHANGE_GROUP, DATABASE_PERMISSION_CHANGE_GROUP, DATABASE_PRINCIPAL_CHANGE_GROUP, DATABASE_PRINCIPAL_IMPERSONATION_GROUP, DATABASE_ROLE_MEMBER_CHANGE_GROUP, DBCC_GROUP, LOGIN_CHANGE_PASSWORD_GROUP, SCHEMA_OBJECT_CHANGE_GROUP, SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP, SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP, SERVER_OBJECT_CHANGE_GROUP, SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP, SERVER_OBJECT_PERMISSION_CHANGE_GROUP, SERVER_OPERATION_GROUP, SERVER_PERMISSION_CHANGE_GROUP, SERVER_PRINCIPAL_IMPERSONATION_GROUP, SERVER_ROLE_MEMBER_CHANGE_GROUP, SERVER_STATE_CHANGE_GROUP, TRACE_CHANGE_GROUP;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name IN ('APPLICATION_ROLE_CHANGE_PASSWORD_GROUP', 'AUDIT_CHANGE_GROUP', 'BACKUP_RESTORE_GROUP', 'DATABASE_CHANGE_GROUP', 'DATABASE_OBJECT_ACCESS_GROUP', 'DATABASE_OBJECT_CHANGE_GROUP', 'DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP', 'DATABASE_OBJECT_PERMISSION_CHANGE_GROUP', 'DATABASE_OWNERSHIP_CHANGE_GROUP', 'DATABASE_OPERATION_GROUP', 'DATABASE_OWNERSHIP_CHANGE_GROUP', 'DATABASE_PERMISSION_CHANGE_GROUP', 'DATABASE_PRINCIPAL_CHANGE_GROUP', 'DATABASE_PRINCIPAL_IMPERSONATION_GROUP', 'DATABASE_ROLE_MEMBER_CHANGE_GROUP', 'DBCC_GROUP', 'LOGIN_CHANGE_PASSWORD_GROUP', 'SCHEMA_OBJECT_CHANGE_GROUP', 'SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP', 'SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP', 'SERVER_OBJECT_CHANGE_GROUP', 'SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP', 'SERVER_OBJECT_PERMISSION_CHANGE_GROUP', 'SERVER_OPERATION_GROUP', 'SERVER_PERMISSION_CHANGE_GROUP', 'SERVER_PRINCIPAL_IMPERSONATION_GROUP', 'SERVER_ROLE_MEMBER_CHANGE_GROUP', 'SERVER_STATE_CHANGE_GROUP') Order by d.audit_action_name;"
    ],
    "Fix": "거부된 동작을 감사하기 위해 서버 감사 명세에 필요한 이벤트를 추가한다: “USE [master]; GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (APPLICATION_ROLE_CHANGE_PASSWORD_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (AUDIT_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (BACKUP_RESTORE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_ACCESS_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_PERMISSION_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OWNERSHIP_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OPERATION_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OWNERSHIP_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PERMISSION_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PRINCIPAL_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PRINCIPAL_IMPERSONATION_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_ROLE_MEMBER_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DBCC_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (LOGIN_CHANGE_PASSWORD_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_PERMISSION_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OPERATION_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_PERMISSION_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_PRINCIPAL_IMPERSONATION_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_ROLE_MEMBER_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_STATE_CHANGE_GROUP ); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (TRACE_CHANGE_GROUP ); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON); GO”.",
    "Fix_sql": [
      "USE [master];",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (APPLICATION_ROLE_CHANGE_PASSWORD_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (AUDIT_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (BACKUP_RESTORE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_ACCESS_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_PERMISSION_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OWNERSHIP_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OPERATION_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OWNERSHIP_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PERMISSION_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PRINCIPAL_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PRINCIPAL_IMPERSONATION_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_ROLE_MEMBER_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DBCC_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (LOGIN_CHANGE_PASSWORD_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_PERMISSION_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OPERATION_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_PERMISSION_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_PRINCIPAL_IMPERSONATION_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_ROLE_MEMBER_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_STATE_CHANGE_GROUP );",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (TRACE_CHANGE_GROUP );",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON);",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79241",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 PPSM(Ports, Protocols, and Services Management) 지침에 따라 조직이 불안전하다고 간주한 네트워크 함수, 포트, 프로토콜 및 서비스를 비활성화 해야 한다. ",
    "Check": "CDMDB는 승인된 네트워크 통신 라이브러리, 포트 및 프로토콜 만을 사용해야 한다. 서버 문서에서 모든 승인된 네트워크 라이브러리, 통신 포트 및 프로토콜 목록을 입수한다. 프로토콜이 데이터베이스에서 활성화 되었는지 확인한다. 만일 서버 문서에서 명확하게 승인되지 않은 포트나 프로토콜이 사용된다면, 조치가 필요하다. ",
    "Check_sql": null,
    "Fix": "승인된 TCP/IP 포트 번호를 데이터베이스 엔진에 부여한다. 1) SSCM >> 콘솔 창 >> “SQL Server Network Configuration” 확장 >> 해당 데이터베이스의 “Protocols” 확장 >> “TCP/IP”를 더블-클릭. 2) “TCP/IP Properties” 다이얼로그 박스의 “IP Addresses” 탭에서 여러 가지 IP 주소가 “IP1, IP2,… IPAll” 포맷으로 보임. 그 중에 하나가 루프백 어댑터의 IP 주소(127.0.0.1). 추가 IP 주소가 컴퓨터의 각 IP 주소에 나타나고 IPv4와 IPv6 주소를 볼 수 있음. 각 주소를 오른쪽-클릭하여 구성하려는 IP 주소를 식별하기 위해 “Properties”를 클릭. 3) 만일 “TCP Dynamic Ports” 다이얼로그 박스가 “0”이면, 데이터베이스 엔진이 동적 포트를 리스닝 하고 있다는 표시이고 “0”을 삭제. 4) “IPn Properties Area” 박스의 “TCP Port” 박스에서, 리스닝 하는 IP 주소의 포트 번호를 입력하고 “OK”를 클릭. 5) 콘솔 창에서, “SQL Server Services”를 클릭. 6) 상세 창에서 “SQL Server(데이터베이스 명)”을 오른쪽-클릭하고 데이터베이스를 재시작하기 위해 “Restart”를 클릭. 데이터베이스의 서버 네트워크 프로토콜을 비활성화 하기 위해: 1) SSCM >> 콘솔 창 >> “SQL Server Network Configuration”을 확장 2) 콘솔 창에서 해당 데이터베이스의 “Protocols” 클릭. 3) 상세 창에서 변경하려는 프로토콜을 오른쪽-클릭하고 “Enable”이나 “Disable”을 클릭. 4) 콘솔 창에서, “SQL Server Services”를 클릭. 5) 상세 창에서, “SQL Server(데이터베이스 명)”을 오른쪽 클릭하고 SQL Server Service를 재시작하기 위해 “Restart”를 클릭.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79243",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 각 실행 프로세스에 개별 실행 도메인을 유지 관리해야 한다.",
    "Check": "CLR(Common Language Runtime) 어셈블리가 필요한지 여부를 판단하기 위해 서버 문서를 검토한다. CLR이 데이터베이스에서 활성화되었는지 판단하기 위해 다음 쿼리를 실행한다: “SELECT name, value, value_in_use FROM sys.configurations WHERE name = 'clr enabled';”. 만일 “value_in_use”가 “1”이고 CLR이 필요하지 않다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT name, value, value_in_use FROM sys.configurations WHERE name = 'clr enabled';"
    ],
    "Fix": "다음 쿼리를 실행하여 SQL Server의 CLR 지원을 비활성화 한다: “EXEC sp_configure 'clr enabled', 0 GO RECONFIGURE GO”.",
    "Fix_sql": [
      "EXEC sp_configure 'clr enabled', 0 GO RECONFIGURE GO;"
    ]
  },
  {
    "Id": "CDMV-79245",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB 서비스는 유일 전용 사용자 계정 하에 실행되도록 구성되어야 한다.",
    "Check": "필요 서비스 계정 목록을 입수하기 위해 서버 문서를 검토한다. 서버에 설치된 모든 SQL Server 서비스를 구성하는 계정을 검토한다. 시작 >> “SQL Server Configuration Manager” 입력 >> 프로그램 기동 >> SQL Server Services 트리 노드 클릭 >> 각 서비스의 “Log On As” 컬럼 확인. 만일 서비스가 동일 서비스 계정으로 구성되거나 문서화 되지 않고 인가되지 않은 계정으로 구성된다면, 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "문서화된 전용 계정을 가지도록 SQL Server를 구성한다. 비-도메인 서버인 경우, 가상 서비스 계정(VSA, Virtual Service Account)를 고려한다. 상세한 정보는 “https://msdn.MS.com/en-us/library/ms143504.aspx#VA_Desc”를 참조하기 바란다. 단독 도메인-결합 서버인 경우, 관리 서비스 계정을 고려한다. 상세한 정보는 “https://msdn.MS.com/en-us/library/ms143504.aspx#MSA”를 참조하기 바란다. 클러스터된 데이터베이스인 경우, 그룹 관리 서비스 계정을 고려한다. 상세한 정보는 “https://msdn.MS.com/en-us/library/ms143504.aspx#GMSA”나 “https://blogs.msdn.MS.com/markweberblog/20xx/05/25/group-managed-service-accounts-gmsa-and-sql-server-20xx/”를 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79247",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "업데이트가 SQL Server 소프트웨어에 적용될 때, 불필요하거나 대체된 소프트웨어는 제거되어야 한다.",
    "Check": "서버 문서에서, 필요 컴포넌트 목록을 입수한다. 서버에 설치된 컴포넌트 목록을 생성한다. 시작 >> “SQL Server 20xx Installation Center” 입력 >> 프로그램 기동 >> “Tools” 클릭 >> “Installed SQL Server features discovery report”를 클릭. 필요 컴포넌트 목록과 기능 목록을 비교한다. 만일 기능이 설치되었지만, 필요하지 않다면, 조치가 필요하다. ",
    "Check_sql": null,
    "Fix": "필요하지 않은 모든 기능을 제거한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79249",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "SQL Server 보안 관련 소프트웨어 업데이트가 유권 출처(예, IAVM/CTO/DTM/STIG)가 지시한 기간 내에 설치되어야 한다.",
    "Check": "소프트웨어 패치가 각 패치에 정의된 기간 내에 SQL Server에 지속적으로 적용되었다는 증거를 입수한다. 지원되기 위해, MS는 취약성이 알려진 보안 패치에 의해 지원되는 버전을 공지해야 한다. “https://support.MS.com/en-us/lifecycle?C2=1044”를 참조하기 바란다. 다음 스크립트를 실행하여 SQL Server 버전을 확인한다: “Print @@version” 만일 SQL Server 버전이 지원되지 않는다면, 조치가 필요하다. 만일 이런 증거를 입수할 수 없거나 입수된 증거가 비-준수 패턴을 보인다면, 조치가 필요하다. ",
    "Check_sql": null,
    "Fix": "MS 지원 버전으로 SQL Server를 업그레이드 한다. 패치가 허용된 기간 내에 SQL Server에 지속적으로 적용되도록 정책/절차를 수립하고 고수한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79251",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 보안 오브젝트가 접근될 경우에 감사 레코드를 생성해야 한다.",
    "Check": "다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. 만일 권한/허가/역할 멤버십 정보 조회의 감사가 필요하다면, 서버 감사 명세에 \"SCHEMA_OBJECT_ACCESS_GROUP\"이 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName', s.name AS 'SpecName',   d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';”. 만일 \"SCHEMA_OBJECT_ACCESS_GROUP\"이 활성 감사에서 리턴되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName',   d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';"
    ],
    "Fix": "권한/허가/역할 멤버십 정보 조회를 감사하는 감사가 적용 한다. “SQL 2016 Audit.sql” 파일을 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79253",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 보안 오브젝트 접근 시도가 실패할 경우에 감사 레코드를 생성해야 한다.",
    "Check": "권한/허가/역할 멤버십 정보 조회의 감사가 필요한지 판단하기 위해 시스템 문서를 검토한다. 만일 필요하지 않다면, 조치가 필요하지 않다. 만일 문서가 존재하지 않는다면, 조치가 필요하다. 다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. 만일 권한/허가/역할 멤버십 정보 조회의 감사가 필요하다면, 서버 감사 명세에 \"SCHEMA_OBJECT_ACCESS_GROUP\"이 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName', s.name AS 'SpecName',   d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';”. 만일 \"SCHEMA_OBJECT_ACCESS_GROUP\"이 활성 감사에서 리턴되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName',   d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';"
    ],
    "Fix": "권한/허가/역할 멤버십 정보 조회를 감사하는 감사가 적용 한다. “SQL 2016 Audit.sql” 파일을 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79255",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 분류된 정보(예, 기밀/보안 수준)의 접근될 경우에 감사 레코드를 생성해야 한다.",
    "Check": "데이터 기밀-분류의 조회될 경우에 감사가 필요한지 판단하기 위해 시스템 문서를 검토한다. 만일 필요하지 않다면, 조치가 필요하지 않다. 만일 문서가 존재하지 않는다면, 조치가 필요하다. 다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. 만일 권한/허가/역할 멤버십 정보 조회의 감사가 필요하다면, 서버 감사 명세에 \"SCHEMA_OBJECT_ACCESS_GROUP\"이 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName', s.name AS 'SpecName',   d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';”. 만일 \"SCHEMA_OBJECT_ACCESS_GROUP\"이 활성 감사에서 리턴되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName',   d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';"
    ],
    "Fix": "데이터 기밀-분류가 조회될 경우에 감사하는 감사를 적용한다.. “SQL 2016 Audit.sql” 파일을 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79257",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 분류된 정보(예, 기밀/보안 수준)의 접근 시도가 실패할 경우에 감사 레코드를 생성해야 한다.",
    "Check": "데이터 기밀-분류의 조회가 실패할 경우에 감사가 필요한지 판단하기 위해 시스템 문서를 검토한다. 만일 필요하지 않다면, 조치가 필요하지 않다. 만일 문서가 존재하지 않는다면, 조치가 필요하다. 다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. 만일 권한/허가/역할 멤버십 정보 조회의 감사가 필요하다면, 서버 감사 명세에 \"SCHEMA_OBJECT_ACCESS_GROUP\"이 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName', s.name AS 'SpecName',   d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';”. 만일 \"SCHEMA_OBJECT_ACCESS_GROUP\"이 활성 감사에서 리턴되지 않는다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName',   d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';"
    ],
    "Fix": "데이터 기밀-분류 조회가 실패할 경우에 감사하는 감사를 적용한다. “SQL 2016 Audit.sql” 파일을 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79259",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 권한/허가가 추가될 경우에 감사 레코드를 생성해야 한다.",
    "Check": "CDMDB STIG 보안 준수 감사에 사용되는 “SQL Server Audit”을 확인한다. 만일 다음 이벤트가 포함되지 않았다면, 조치가 필요하다: “DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP” “https://msdn.MS.com/en-us/library/cc280663.aspx”를 참조하기 바란다.",
    "Check_sql": null,
    "Fix": "CDMDB STIG 보안 준수 감사에 사용되는 “SQL Server Audit”에 다음 이벤트를 추가한다: “DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP” “SQL 2016 Audit.sql” 파일을 참조하기 바란다. 또한 “https://msdn.MS.com/en-us/library/cc280663.aspx”를 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79261",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 권한/허가의 추가 시도가 실패할 경우에 감사 레코드를 생성해야 한다.",
    "Check": "CDMDB STIG 보안 준수 감사에 사용되는 “SQL Server Audit”을 확인한다. 만일 다음 이벤트가 포함되지 않았다면, 조치가 필요하다: “DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP” “https://msdn.MS.com/en-us/library/cc280663.aspx”를 참조하기 바란다.",
    "Check_sql": null,
    "Fix": "CDMDB STIG 보안 준수 감사에 사용되는 “SQL Server Audit”에 다음 이벤트를 추가한다: “DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP” “SQL 2016 Audit.sql” 파일을 참조하기 바란다. 또한 “https://msdn.MS.com/en-us/library/cc280663.aspx”를 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79263",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 권한/허가가 변경될 경우에 감사 레코드를 생성해야 한다.",
    "Check": "CDMDB STIG 보안 준수 감사에 사용되는 “SQL Server Audit”을 확인한다. 만일 다음 이벤트가 포함되지 않았다면, 조치가 필요하다: “DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP” “https://msdn.MS.com/en-us/library/cc280663.aspx”를 참조하기 바란다.",
    "Check_sql": null,
    "Fix": "CDMDB STIG 보안 준수 감사에 사용되는 “SQL Server Audit”에 다음 이벤트를 추가한다: “DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP” “SQL 2016 Audit.sql” 파일을 참조하기 바란다. 또한 “https://msdn.MS.com/en-us/library/cc280663.aspx”를 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79265",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 권한/허가의 변경 시도가 실패할 경우에 감사 레코드를 생성해야 한다.",
    "Check": "CDMDB STIG 보안 준수 감사에 사용되는 “SQL Server Audit”을 확인한다. 만일 다음 이벤트가 포함되지 않았다면, 조치가 필요하다: “DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP” “https://msdn.MS.com/en-us/library/cc280663.aspx”를 참조하기 바란다.",
    "Check_sql": null,
    "Fix": "CDMDB STIG 보안 준수 감사에 사용되는 “SQL Server Audit”에 다음 이벤트를 추가한다: “DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP” “SQL 2016 Audit.sql” 파일을 참조하기 바란다. 또한 “https://msdn.MS.com/en-us/library/cc280663.aspx”를 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79267",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 보안 오브젝트가 변경될 경우에 감사 레코드를 생성해야 한다.",
    "Check": "다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. \"SCHEMA_OBJECT_CHANGE_GROUP\"이 서버 감사 명세에 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName',   s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';”. 만일 \"SCHEMA_OBJECT_CHANGE_GROUP\"이 활성 감사에서 리턴되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName',   s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';"
    ],
    "Fix": "서버 감사 명세에 \"SCHEMA_OBJECT_CHANGE_GROUP\"을 추가한다: “USE [master]; GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_CHANGE_GROUP); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON); GO”.  “SQL 2016 Audit.sql” 파일을 참조하기 바란다.",
    "Fix_sql": [
      "USE [master];",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_CHANGE_GROUP);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON);",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79269",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 보안 오브젝트의 변경 시도가 실패할 경우에 감사 레코드를 생성해야 한다.",
    "Check": "다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. \"SCHEMA_OBJECT_CHANGE_GROUP\"이 서버 감사 명세에 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';”. 만일 \"SCHEMA_OBJECT_CHANGE_GROUP\"이 활성 감사에서 리턴되지 않는다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';"
    ],
    "Fix": "서버 감사 명세에 \"SCHEMA_OBJECT_CHANGE_GROUP\"을 추가한다: “USE [master]; GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_CHANGE_GROUP); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON); GO”. “SQL 2016 Audit.sql” 파일을 참조하기 바란다.",
    "Fix_sql": [
      "USE [master];",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_CHANGE_GROUP);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON);",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79271",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 분류화된 정보(예, 기밀/보안 수준)가 변경될 경우에 감사 레코드를 생성해야 한다.",
    "Check": "CDMDB는 데이터 기밀분류가 변경될 때 감사가 필요한지 판단하기 위해 시스템 문서를 검토한다. 만일 필요하지 않다면, 조치가 필요하지 않다. 만일 문서가 존재하지 않는다면, 조치가 필요하다. 다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status',  audit_file_path AS 'Current Audit File' FROM  sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. 만일 권한/허가/역할 멤버십 정보 조회의 감사가 필요하다면, \"SCHEMA_OBJECT_ACCESS_GROUP\"이 서버 감사 명세에 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName',  s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';”. 만일 \"SCHEMA_OBJECT_ACCESS_GROUP\"이 활성 감사에서 리턴되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status',  audit_file_path AS 'Current Audit File' FROM  sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName',  s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';"
    ],
    "Fix": "데이터 기밀분류가 변경될 때 감사하는 감사를 적용한다. “SQL 2016 Audit.sql” 파일을 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79273",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 분류화된 정보(예, 기밀/보안 수준)의 변경 시도가 실패할 경우에 감사 레코드를 생성해야 한다.",
    "Check": "CDMDB는 데이터 기밀분류의 변경이 실패될 때 감사가 필요한지 판단하기 위해 시스템 문서를 검토한다. 만일 필요하지 않다면, 조치가 필요하지 않다. 만일 문서가 존재하지 않는다면, 조치가 필요하다. 다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status',  audit_file_path AS 'Current Audit File' FROM  sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. 만일 권한/허가/역할 멤버십 정보 조회의 감사가 필요하다면, \"SCHEMA_OBJECT_ACCESS_GROUP\"이 서버 감사 명세에 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName',  s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';”. 만일 \"SCHEMA_OBJECT_ACCESS_GROUP\"이 활성 감사에서 리턴되지 않는다면, 조치가 필요하다.  ",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status',  audit_file_path AS 'Current Audit File' FROM  sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName',  s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';"
    ],
    "Fix": "데이터 기밀분류의 변경이 실패할 때 감사하는 감사를 적용한다. “SQL 2016 Audit.sql” 파일을 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79275",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 권한/허가가 삭제될 경우에 감사 레코드를 생성해야 한다.",
    "Check": "CDMDB STIG 보안 준수 감사에 사용되는 “SQL Server Audit”을 확인한다: 만일 다음 이벤트가 포함되지 않는다면, 조치가 필요하다: “DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP” “https://msdn.MS.com/en-us/library/cc280663.aspx”를 참조하기 바란다.",
    "Check_sql": null,
    "Fix": "CDMDB STIG 보안 준수 감사에 사용되는 “SQL Server Audit”에 다음 이벤트를 추가한다: “DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP”. “SQL 2016 Audit.sql” 파일을 참조하기 바란다. 또한 “https://msdn.MS.com/en-us/library/cc280663.aspx” 를 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79277",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 권한/허가의 삭제 시도가 실패할 경우에 감사 레코드를 생성해야 한다.",
    "Check": "CDMDB STIG 보안 준수 감사에 사용되는 “SQL Server Audit”을 확인한다: 만일 다음 이벤트가 포함되지 않는다면, 조치가 필요하다: “DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP” “https://msdn.MS.com/en-us/library/cc280663.aspx”를 참조하기 바란다.",
    "Check_sql": null,
    "Fix": "CDMDB STIG 보안 준수 감사에 사용되는 “SQL Server Audit”에 다음 이벤트를 추가한다: “DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP”. “SQL 2016 Audit.sql” 파일을 참조하기 바란다. 또한 “https://msdn.MS.com/en-us/library/cc280663.aspx” 를 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79279",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 보안 오브젝트가 변경될 겨우 감사 레코드를 생성해야 한다.",
    "Check": "다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. \"SCHEMA_OBJECT_CHANGE_GROUP\"이 서버 감사 명세에 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';”. 만일 \"SCHEMA_OBJECT_CHANGE_GROUP\"이 활성 감사에서 리턴되지 않는다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';"
    ],
    "Fix": "서버 감사 명세에 \"SCHEMA_OBJECT_CHANGE_GROUP”을 추가한다: “USE [master]; GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_CHANGE_GROUP); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON); GO”. “SQL 2016 Audit.sql” 파일을 참조하기 바란다.",
    "Fix_sql": [
      "USE [master];",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_CHANGE_GROUP);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON);",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79281",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 보안 오브젝트의 삭제 시도가 실패할 경우에 감사 레코드를 생성해야 한다.",
    "Check": "다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. \"SCHEMA_OBJECT_CHANGE_GROUP\"이 서버 감사 명세에 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';”. 만일 \"SCHEMA_OBJECT_CHANGE_GROUP\"이 활성 감사에서 리턴되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';"
    ],
    "Fix": "서버 감사 명세에 \"SCHEMA_OBJECT_CHANGE_GROUP”을 추가한다: “USE [master]; GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_CHANGE_GROUP); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON); GO”. “SQL 2016 Audit.sql” 파일을 참조하기 바란다.",
    "Fix_sql": [
      "USE [master];",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_CHANGE_GROUP);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON);",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79283",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 분류화된 정보(예, 기밀/보안 수준)가 삭제될 경우에 감사 레코드를 생성해야 한다. ",
    "Check": "CDMDB 데이터 기밀분류가 삭제될 경우에 감사가 필요한지 판단하기 위해 시스템 문서를 검토한다. 만일 필요하지 않다면, 조치가 필요하지 않다. 만일 문서가 존재하지 않는다면, 조치가 필요하다. 다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. 만일 권한/허가/역할 멤버십 정보 조회의 감사가 필요하다면, \"SCHEMA_OBJECT_ACCESS_GROUP\"이 서버 감사 명세에 포함되는지를 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName',  s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';”. 만일 \"SCHEMA_OBJECT_ACCESS_GROUP\"이 활성 감사에서 리턴되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName',  s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';"
    ],
    "Fix": "데이터 기밀분류가 삭제될 경우에 감사를 적용한다. “SQL 2016 Audit.sql” 파일을 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79285",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 분류화된 정보(예, 기밀/보안 수준)의 삭제 시도가 실패할 경우에 감사 레코드를 생성해야 한다.",
    "Check": "CDMDB 데이터 기밀분류의 삭제가 실패할 경우에 감사가 필요한지 판단하기 위해 시스템 문서를 검토한다. 만일 필요하지 않다면, 조치가 필요하지 않다. 만일 문서가 존재하지 않는다면, 조치가 필요하다. 다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. 만일 권한/허가/역할 멤버십 정보 조회의 감사가 필요하다면, \"SCHEMA_OBJECT_ACCESS_GROUP\"이 서버 감사 명세에 포함되는지를 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName',  s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';”. 만일 \"SCHEMA_OBJECT_ACCESS_GROUP\"이 활성 감사에서 리턴되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName',  s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';"
    ],
    "Fix": "데이터 기밀분류의 삭제가 실패할 경우에 감사하는 감사를 적용한다. \"SQL 2016 Audit.sql\" 파일을 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79287",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 로그온이나 연결이 성공할 경우에 감사 레코드를 생성해야 한다.",
    "Check": "다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. \" SUCCESSFUL_LOGIN_GROUP\"이 서버 감사 명세에 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SUCCESSFUL_LOGIN_GROUP';”. 만일 활성 감사에서 \"SUCCESSFUL_LOGIN_GROUP\"이 리턴 된다면, 조치가 필요하지 않다. 만일 활성 감사에서 \"SUCCESSFUL_LOGIN_GROUP\"이 없다면, \"Both failed and successful logins\"가 활성화인지 여부를 판단한다. SSMS >> 데이터베이스 클릭 >> “Properties” 선택 >> “Security” 선택 >> “Login auditing” 설정 확인. 만일 \"Both failed and successful logins\"이 선택되지 않았다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SUCCESSFUL_LOGIN_GROUP';"
    ],
    "Fix": "서버 감사 명세에 \"SUCCESSFUL_LOGIN_GROUP\"를 추가한다: “USE [master]; GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SUCCESSFUL_LOGIN_GROUP); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON); GO”. 다른 방법으로 SSMS >> 데이터베이스 오른쪽-클릭 >> “Properties” 선택 >> “Security” 선택 >> \"Both failed and successful logins\" 선택 >> “OK” 클릭.  ",
    "Fix_sql": [
      "USE [master];",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SUCCESSFUL_LOGIN_GROUP);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON);",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79289",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 로그온이나 연결 시도가 실패할 경우에 감사 레코드를 생성해야 한다.",
    "Check": "다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. \"FAILED_LOGIN_GROUP\"이 서버 감사 명세에 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'FAILED_LOGIN_GROUP';”. 만일 \"FAILED_LOGIN_GROUP\"이 리턴되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'FAILED_LOGIN_GROUP';"
    ],
    "Fix": "서버 감사 명세에 \"FAILED_LOGIN_GROUP\"을 추가한다: “USE [master]; GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (FAILED_LOGIN_GROUP); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON); GO”.",
    "Fix_sql": [
      "USE [master];",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (FAILED_LOGIN_GROUP);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON);",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79291",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 모든 특권 활동이나 다른 시스템-수준 접근에 관한 감사 레코드를 생성해야 한다.",
    "Check": "다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. 다음 이벤트가 서버 감사 명세에 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “APPLICATION_ROLE_CHANGE_PASSWORD_GROUP AUDIT_CHANGE_GROUP BACKUP_RESTORE_GROUP DATABASE_CHANGE_GROUP DATABASE_OBJECT_CHANGE_GROUP DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OPERATION_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_PRINCIPAL_CHANGE_GROUP DATABASE_PRINCIPAL_IMPERSONATION_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP DBCC_GROUP LOGIN_CHANGE_PASSWORD_GROUP SCHEMA_OBJECT_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OPERATION_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_PRINCIPAL_CHANGE_GROUP SERVER_PRINCIPAL_IMPERSONATION_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP SERVER_STATE_CHANGE_GROUP TRACE_CHANGE_GROUP USER_CHANGE_PASSWORD_GROUP”, “SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1  AND d.audit_action_name IN ('APPLICATION_ROLE_CHANGE_PASSWORD_GROUP','AUDIT_CHANGE_GROUP','BACKUP_RESTORE_GROUP','DATABASE_CHANGE_GROUP','DATABASE_OBJECT_CHANGE_GROUP','DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP','DATABASE_OBJECT_PERMISSION_CHANGE_GROUP','DATABASE_OPERATION_GROUP','DATABASE_OWNERSHIP_CHANGE_GROUP','DATABASE_PERMISSION_CHANGE_GROUP','DATABASE_PRINCIPAL_CHANGE_GROUP','DATABASE_PRINCIPAL_IMPERSONATION_GROUP','DATABASE_ROLE_MEMBER_CHANGE_GROUP','DBCC_GROUP','LOGIN_CHANGE_PASSWORD_GROUP','SCHEMA_OBJECT_CHANGE_GROUP','SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP','SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP','SERVER_OBJECT_CHANGE_GROUP','SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP','SERVER_OBJECT_PERMISSION_CHANGE_GROUP','SERVER_OPERATION_GROUP','SERVER_PERMISSION_CHANGE_GROUP','SERVER_PRINCIPAL_CHANGE_GROUP','SERVER_PRINCIPAL_IMPERSONATION_GROUP','SERVER_ROLE_MEMBER_CHANGE_GROUP','SERVER_STATE_CHANGE_GROUP','TRACE_CHANGE_GROUP','USER_CHANGE_PASSWORD_GROUP');”. 만일 식별된 그룹이 리턴되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "BACKUP_RESTORE_GROUP DATABASE_CHANGE_GROUP DATABASE_OBJECT_CHANGE_GROUP DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OPERATION_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_PRINCIPAL_CHANGE_GROUP DATABASE_PRINCIPAL_IMPERSONATION_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP DBCC_GROUP LOGIN_CHANGE_PASSWORD_GROUP SCHEMA_OBJECT_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OPERATION_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_PRINCIPAL_CHANGE_GROUP SERVER_PRINCIPAL_IMPERSONATION_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP SERVER_STATE_CHANGE_GROUP TRACE_CHANGE_GROUP USER_CHANGE_PASSWORD_GROUP;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1  AND d.audit_action_name IN ('APPLICATION_ROLE_CHANGE_PASSWORD_GROUP','AUDIT_CHANGE_GROUP','BACKUP_RESTORE_GROUP','DATABASE_CHANGE_GROUP','DATABASE_OBJECT_CHANGE_GROUP','DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP','DATABASE_OBJECT_PERMISSION_CHANGE_GROUP','DATABASE_OPERATION_GROUP','DATABASE_OWNERSHIP_CHANGE_GROUP','DATABASE_PERMISSION_CHANGE_GROUP','DATABASE_PRINCIPAL_CHANGE_GROUP','DATABASE_PRINCIPAL_IMPERSONATION_GROUP','DATABASE_ROLE_MEMBER_CHANGE_GROUP','DBCC_GROUP','LOGIN_CHANGE_PASSWORD_GROUP','SCHEMA_OBJECT_CHANGE_GROUP','SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP','SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP','SERVER_OBJECT_CHANGE_GROUP','SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP','SERVER_OBJECT_PERMISSION_CHANGE_GROUP','SERVER_OPERATION_GROUP','SERVER_PERMISSION_CHANGE_GROUP','SERVER_PRINCIPAL_CHANGE_GROUP','SERVER_PRINCIPAL_IMPERSONATION_GROUP','SERVER_ROLE_MEMBER_CHANGE_GROUP','SERVER_STATE_CHANGE_GROUP','TRACE_CHANGE_GROUP','USER_CHANGE_PASSWORD_GROUP');"
    ],
    "Fix": "서버 감사 명세에 필요 이벤트를 추가한다: “USE [master]; GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (APPLICATION_ROLE_CHANGE_PASSWORD_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (AUDIT_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (BACKUP_RESTORE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_PERMISSION_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OPERATION_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OWNERSHIP_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PERMISSION_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PRINCIPAL_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PRINCIPAL_IMPERSONATION_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_ROLE_MEMBER_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DBCC_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (LOGIN_CHANGE_PASSWORD_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_PERMISSION_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OPERATION_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_PERMISSION_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_PRINCIPAL_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_PRINCIPAL_IMPERSONATION_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_ROLE_MEMBER_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_STATE_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (TRACE_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (USER_CHANGE_PASSWORD_GROUP); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON);  GO”.",
    "Fix_sql": [
      "USE [master];",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (APPLICATION_ROLE_CHANGE_PASSWORD_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (AUDIT_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (BACKUP_RESTORE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_PERMISSION_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OPERATION_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OWNERSHIP_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PERMISSION_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PRINCIPAL_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PRINCIPAL_IMPERSONATION_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_ROLE_MEMBER_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DBCC_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (LOGIN_CHANGE_PASSWORD_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_PERMISSION_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OPERATION_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_PERMISSION_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_PRINCIPAL_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_PRINCIPAL_IMPERSONATION_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_ROLE_MEMBER_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_STATE_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (TRACE_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (USER_CHANGE_PASSWORD_GROUP);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON);",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79293",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 다른 시스템-수준 접근이나 특권 활동 실행 시도가 실패할 경우에 감사 레코드를 생성해야 한다.",
    "Check": "다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. 다음 이벤트가 서버 감사 명세에 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “APPLICATION_ROLE_CHANGE_PASSWORD_GROUP AUDIT_CHANGE_GROUP BACKUP_RESTORE_GROUP DATABASE_CHANGE_GROUP DATABASE_OBJECT_CHANGE_GROUP DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OPERATION_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_PRINCIPAL_CHANGE_GROUP DATABASE_PRINCIPAL_IMPERSONATION_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP DBCC_GROUP LOGIN_CHANGE_PASSWORD_GROUP SCHEMA_OBJECT_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OPERATION_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_PRINCIPAL_CHANGE_GROUP SERVER_PRINCIPAL_IMPERSONATION_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP SERVER_STATE_CHANGE_GROUP TRACE_CHANGE_GROUP USER_CHANGE_PASSWORD_GROUP”, “SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1  AND d.audit_action_name IN ('APPLICATION_ROLE_CHANGE_PASSWORD_GROUP','AUDIT_CHANGE_GROUP','BACKUP_RESTORE_GROUP','DATABASE_CHANGE_GROUP','DATABASE_OBJECT_CHANGE_GROUP','DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP','DATABASE_OBJECT_PERMISSION_CHANGE_GROUP','DATABASE_OPERATION_GROUP','DATABASE_OWNERSHIP_CHANGE_GROUP','DATABASE_PERMISSION_CHANGE_GROUP','DATABASE_PRINCIPAL_CHANGE_GROUP','DATABASE_PRINCIPAL_IMPERSONATION_GROUP','DATABASE_ROLE_MEMBER_CHANGE_GROUP','DBCC_GROUP','LOGIN_CHANGE_PASSWORD_GROUP','SCHEMA_OBJECT_CHANGE_GROUP','SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP','SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP','SERVER_OBJECT_CHANGE_GROUP','SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP','SERVER_OBJECT_PERMISSION_CHANGE_GROUP','SERVER_OPERATION_GROUP','SERVER_PERMISSION_CHANGE_GROUP','SERVER_PRINCIPAL_CHANGE_GROUP','SERVER_PRINCIPAL_IMPERSONATION_GROUP','SERVER_ROLE_MEMBER_CHANGE_GROUP','SERVER_STATE_CHANGE_GROUP','TRACE_CHANGE_GROUP','USER_CHANGE_PASSWORD_GROUP');”. 만일 식별된 그룹이 리턴되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "BACKUP_RESTORE_GROUP DATABASE_CHANGE_GROUP DATABASE_OBJECT_CHANGE_GROUP DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OPERATION_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_PRINCIPAL_CHANGE_GROUP DATABASE_PRINCIPAL_IMPERSONATION_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP DBCC_GROUP LOGIN_CHANGE_PASSWORD_GROUP SCHEMA_OBJECT_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OPERATION_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_PRINCIPAL_CHANGE_GROUP SERVER_PRINCIPAL_IMPERSONATION_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP SERVER_STATE_CHANGE_GROUP TRACE_CHANGE_GROUP USER_CHANGE_PASSWORD_GROUP;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1  AND d.audit_action_name IN ('APPLICATION_ROLE_CHANGE_PASSWORD_GROUP','AUDIT_CHANGE_GROUP','BACKUP_RESTORE_GROUP','DATABASE_CHANGE_GROUP','DATABASE_OBJECT_CHANGE_GROUP','DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP','DATABASE_OBJECT_PERMISSION_CHANGE_GROUP','DATABASE_OPERATION_GROUP','DATABASE_OWNERSHIP_CHANGE_GROUP','DATABASE_PERMISSION_CHANGE_GROUP','DATABASE_PRINCIPAL_CHANGE_GROUP','DATABASE_PRINCIPAL_IMPERSONATION_GROUP','DATABASE_ROLE_MEMBER_CHANGE_GROUP','DBCC_GROUP','LOGIN_CHANGE_PASSWORD_GROUP','SCHEMA_OBJECT_CHANGE_GROUP','SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP','SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP','SERVER_OBJECT_CHANGE_GROUP','SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP','SERVER_OBJECT_PERMISSION_CHANGE_GROUP','SERVER_OPERATION_GROUP','SERVER_PERMISSION_CHANGE_GROUP','SERVER_PRINCIPAL_CHANGE_GROUP','SERVER_PRINCIPAL_IMPERSONATION_GROUP','SERVER_ROLE_MEMBER_CHANGE_GROUP','SERVER_STATE_CHANGE_GROUP','TRACE_CHANGE_GROUP','USER_CHANGE_PASSWORD_GROUP');"
    ],
    "Fix": "서버 감사 명세에 필요 이벤트를 추가한다: “USE [master]; GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (APPLICATION_ROLE_CHANGE_PASSWORD_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (AUDIT_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (BACKUP_RESTORE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_PERMISSION_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OPERATION_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OWNERSHIP_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PERMISSION_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PRINCIPAL_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PRINCIPAL_IMPERSONATION_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_ROLE_MEMBER_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DBCC_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (LOGIN_CHANGE_PASSWORD_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_PERMISSION_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OPERATION_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_PERMISSION_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_PRINCIPAL_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_PRINCIPAL_IMPERSONATION_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_ROLE_MEMBER_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_STATE_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (TRACE_CHANGE_GROUP); ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (USER_CHANGE_PASSWORD_GROUP); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON);  GO”.",
    "Fix_sql": [
      "USE [master];",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (APPLICATION_ROLE_CHANGE_PASSWORD_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (AUDIT_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (BACKUP_RESTORE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OBJECT_PERMISSION_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OPERATION_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_OWNERSHIP_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PERMISSION_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PRINCIPAL_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_PRINCIPAL_IMPERSONATION_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DATABASE_ROLE_MEMBER_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (DBCC_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (LOGIN_CHANGE_PASSWORD_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OBJECT_PERMISSION_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_OPERATION_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_PERMISSION_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_PRINCIPAL_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_PRINCIPAL_IMPERSONATION_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_ROLE_MEMBER_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SERVER_STATE_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (TRACE_CHANGE_GROUP);",
      "ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (USER_CHANGE_PASSWORD_GROUP);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON);",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79295",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 데이터베이스의 사용자 접근에 관한 시작/종료 시간을 보여주는 감사 레코드를 생성해야 한다.",
    "Check": "다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. 다음 이벤트가 서버 감사 명세에 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “APPLICATION_ROLE_CHANGE_PASSWORD_GROUP AUDIT_CHANGE_GROUP BACKUP_RESTORE_GROUP DATABASE_CHANGE_GROUP DATABASE_OBJECT_CHANGE_GROUP DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OPERATION_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_PRINCIPAL_CHANGE_GROUP DATABASE_PRINCIPAL_IMPERSONATION_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP DBCC_GROUP LOGIN_CHANGE_PASSWORD_GROUP SCHEMA_OBJECT_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OPERATION_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_PRINCIPAL_CHANGE_GROUP SERVER_PRINCIPAL_IMPERSONATION_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP SERVER_STATE_CHANGE_GROUP TRACE_CHANGE_GROUP USER_CHANGE_PASSWORD_GROUP” “SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1  AND d.audit_action_name IN ('APPLICATION_ROLE_CHANGE_PASSWORD_GROUP','AUDIT_CHANGE_GROUP','BACKUP_RESTORE_GROUP','DATABASE_CHANGE_GROUP','DATABASE_OBJECT_CHANGE_GROUP','DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP','DATABASE_OBJECT_PERMISSION_CHANGE_GROUP','DATABASE_OPERATION_GROUP','DATABASE_OWNERSHIP_CHANGE_GROUP','DATABASE_PERMISSION_CHANGE_GROUP','DATABASE_PRINCIPAL_CHANGE_GROUP','DATABASE_PRINCIPAL_IMPERSONATION_GROUP','DATABASE_ROLE_MEMBER_CHANGE_GROUP','DBCC_GROUP','LOGIN_CHANGE_PASSWORD_GROUP','SCHEMA_OBJECT_CHANGE_GROUP','SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP','SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP','SERVER_OBJECT_CHANGE_GROUP','SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP','SERVER_OBJECT_PERMISSION_CHANGE_GROUP','SERVER_OPERATION_GROUP','SERVER_PERMISSION_CHANGE_GROUP','SERVER_PRINCIPAL_CHANGE_GROUP','SERVER_PRINCIPAL_IMPERSONATION_GROUP','SERVER_ROLE_MEMBER_CHANGE_GROUP','SERVER_STATE_CHANGE_GROUP','TRACE_CHANGE_GROUP','USER_CHANGE_PASSWORD_GROUP');”. 만일 식별된 그룹이 리턴되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "BACKUP_RESTORE_GROUP DATABASE_CHANGE_GROUP DATABASE_OBJECT_CHANGE_GROUP DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP DATABASE_OBJECT_PERMISSION_CHANGE_GROUP DATABASE_OPERATION_GROUP DATABASE_OWNERSHIP_CHANGE_GROUP DATABASE_PERMISSION_CHANGE_GROUP DATABASE_PRINCIPAL_CHANGE_GROUP DATABASE_PRINCIPAL_IMPERSONATION_GROUP DATABASE_ROLE_MEMBER_CHANGE_GROUP DBCC_GROUP LOGIN_CHANGE_PASSWORD_GROUP SCHEMA_OBJECT_CHANGE_GROUP SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OBJECT_CHANGE_GROUP SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP SERVER_OBJECT_PERMISSION_CHANGE_GROUP SERVER_OPERATION_GROUP SERVER_PERMISSION_CHANGE_GROUP SERVER_PRINCIPAL_CHANGE_GROUP SERVER_PRINCIPAL_IMPERSONATION_GROUP SERVER_ROLE_MEMBER_CHANGE_GROUP SERVER_STATE_CHANGE_GROUP TRACE_CHANGE_GROUP USER_CHANGE_PASSWORD_GROUP;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1  AND d.audit_action_name IN ('APPLICATION_ROLE_CHANGE_PASSWORD_GROUP','AUDIT_CHANGE_GROUP','BACKUP_RESTORE_GROUP','DATABASE_CHANGE_GROUP','DATABASE_OBJECT_CHANGE_GROUP','DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP','DATABASE_OBJECT_PERMISSION_CHANGE_GROUP','DATABASE_OPERATION_GROUP','DATABASE_OWNERSHIP_CHANGE_GROUP','DATABASE_PERMISSION_CHANGE_GROUP','DATABASE_PRINCIPAL_CHANGE_GROUP','DATABASE_PRINCIPAL_IMPERSONATION_GROUP','DATABASE_ROLE_MEMBER_CHANGE_GROUP','DBCC_GROUP','LOGIN_CHANGE_PASSWORD_GROUP','SCHEMA_OBJECT_CHANGE_GROUP','SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP','SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP','SERVER_OBJECT_CHANGE_GROUP','SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP','SERVER_OBJECT_PERMISSION_CHANGE_GROUP','SERVER_OPERATION_GROUP','SERVER_PERMISSION_CHANGE_GROUP','SERVER_PRINCIPAL_CHANGE_GROUP','SERVER_PRINCIPAL_IMPERSONATION_GROUP','SERVER_ROLE_MEMBER_CHANGE_GROUP','SERVER_STATE_CHANGE_GROUP','TRACE_CHANGE_GROUP','USER_CHANGE_PASSWORD_GROUP');"
    ],
    "Fix": "서버 감사 명세에 “LOGOUT_GROUP”를 추가한다: “USE [master]; GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (LOGOUT_GROUP); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON); GO”.",
    "Fix_sql": [
      "GOUT_GROUP;",
      "USE [master];",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (LOGOUT_GROUP);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON);",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79297",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB가 다른 워크스테이션에서 동일 사용자에 의한 동시 로그온/연결이 발생할 때 감사 레코드를 생성해야 한다.",
    "Check": "다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. \"SUCCESSFUL_LOGIN_GROUP\"이 서버 감사 명세에 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SUCCESSFUL_LOGIN_GROUP';”. 만일 \"SUCCESSFUL_LOGIN_GROUP\"이 활성 감사에서 리턴 된다면, 조치가 필요하지 않다. 만일 \"SUCCESSFUL_LOGIN_GROUP\"이 활성 감사에서 없다면, \"Both failed and successful logins\"이 활성화 되었는지 여부를 판단한다. SSMS >> 데이터베이스 오른쪽-클릭 >> “Properties” 선택 >> “Security” 선택 >> “Login auditing” 설정 확인. 만일 \"Both failed and successful logins\"이 선택되지 않았다면, 조치가 필요하다.    ",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SUCCESSFUL_LOGIN_GROUP';"
    ],
    "Fix": "서버 감사 명세에 \"SUCCESSFUL_LOGIN_GROUP\"을 추가한다: “USE [master]; GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SUCCESSFUL_LOGIN_GROUP); GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON); GO”. 다른 방법으로 SSMS >> 데이터베이스 오른쪽-클릭 >> “Properties” 선택 >> “Security” 선택 >> \"Both failed and successful logins\" 선택 >> “OK” 클릭. ",
    "Fix_sql": [
      "USE [master];",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = OFF);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION ADD (SUCCESSFUL_LOGIN_GROUP);",
      "GO ALTER SERVER AUDIT SPECIFICATION STIG_AUDIT_SERVER_SPECIFICATION WITH (STATE = ON);",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79299",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 오브젝트 접근이 성공할 경우에 감사 레코드를 생성해야 한다.",
    "Check": "CDMDB가 오브젝트 접근이 성공할 경우에 감사 레코드를 생성해야 되는지 여부를 판단하기 위해 시스템 문서를 검토한다. 만일 필요하지 않다면, 조치가 필요하지 않다. 만일 문서가 존재하지 않는다면, 조치가 필요하다. 다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. 만일 권한/허가/역할 멤버십 정보 조회의 감사가 필요하다면, “\"SCHEMA_OBJECT_ACCESS_GROUP\"가 서버 감사 명세에 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';”. 만일 \"SCHEMA_OBJECT_ACCESS_GROUP\"이 활성 감사에서 리턴되지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';"
    ],
    "Fix": "오브젝트 접근이 성공할 경우에 감사하는 감사를 적용한다. “SQL 2016 Audit.sql” 파일을 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79301",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 오브젝트 접근이 실패할 경우에 감사 레코드를 생성해야 한다.",
    "Check": "CDMDB가 오브젝트 접근이 실패할 경우에 감사 레코드를 생성해야 되는지 여부를 판단하기 위해 시스템 문서를 검토한다. 만일 필요하지 않다면, 조치가 필요하지 않다. 만일 문서가 존재하지 않는다면, 조치가 필요하다. 다음 쿼리를 실행하여 감사가 구성되고 시작되는지 판단한다: “SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;”. 만일 레코드가 리턴되지 않는다면, 조치가 필요하다. 만일 권한/허가/역할 멤버십 정보 조회의 감사가 필요하다면, “\"SCHEMA_OBJECT_ACCESS_GROUP\"가 서버 감사 명세에 포함되는지 검증하기 위해 다음 쿼리를 실행한다: “SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';”. 만일 \"SCHEMA_OBJECT_ACCESS_GROUP\"이 활성 감사에서 리턴되지 않는다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT name AS 'Audit Name', status_desc AS 'Audit Status', audit_file_path AS 'Current Audit File' FROM sys.dm_server_audit_status;",
      "SELECT a.name AS 'AuditName', s.name AS 'SpecName', d.audit_action_name AS 'ActionName', d.audited_result AS 'Result' FROM sys.server_audit_specifications s JOIN sys.server_audits a ON s.audit_guid = a.audit_guid JOIN sys.server_audit_specification_details d ON s.server_specification_id = d.server_specification_id WHERE a.is_state_enabled = 1 AND d.audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';"
    ],
    "Fix": "오브젝트 접근이 실패할 경우에 감사하는 감사를 적용한다. “SQL 2016 Audit.sql” 파일을 참조하기 바란다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79303",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 데이터베이스의 모든 직접적 접근에 감사 레코드를 생성해야 한다.",
    "Check": "“Server Audits”가 레코드를 필터링 하도록 구성되었는지 여부를 판단한다. 다음 쿼리를 실행한다: “SELECT name AS AuditName, predicate AS AuditFilter FROM sys.server_audits WHERE predicate IS NOT NULL;”. 만일 어떤 감사가 리턴 된다면, 관리자 활동이 제외되는지 여부를 판단하기 위해 관련된 필터를 검토한다. 만일 감사가 관리자 활동을 제외하도록 구성되었다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name AS AuditName, predicate AS AuditFilter FROM sys.server_audits WHERE predicate IS NOT NULL;"
    ],
    "Fix": "필요 “데이터베이스 감사”에 관한 시스템 문서를 확인한다. 필수 감사를 제외하거나 감소시키는 감사 필터를 제거한다. 관리자 활동이 제외되지 않도록 필터를 갱신한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79305",
    "Risk": "H",
    "Status": "Ready",
    "Subject": "CDMDB는 디지털 서명을 제공하기 위해 KISA-검증 암호화 모듈을 구현해야 한다.",
    "Check": "Windows가 디지털 서명에 KISA-검증 알고리즘을 사용하도록 구성되었는지 검증한다.",
    "Check_sql": null,
    "Fix": "Windows가 디지털 서명에 KISA-검증 알고리즘을 사용하도록 구성한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79307",
    "Risk": "H",
    "Status": "Ready",
    "Subject": "CDMDB는 암호화 해시를 생성하고 검증하기 위해 KISA-검증 암호화 모듈을 구현해야 한다.",
    "Check": "Windows가 암호화 해시에 KISA-검증 알고리즘을 사용하도록 구성되었는지 검증한다.",
    "Check_sql": null,
    "Fix": "Windows가 암호화 해시에 KISA-검증 알고리즘을 사용하도록 구성한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79309",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 데이터 소유자 요구사항에 따라 기밀성 및 암호화 보호가 필요한 비-기밀분류 정보를 보호하기 위해 KISA-검증 암호화 모듈을 구현해야 한다.",
    "Check": "시스템이 암호화되어야 하는 데이터를 가지지 않는지 서버 문서를 검토한다. Windows가 비-기밀분류 정보에 KISA-인정 알고리즘을 사용하도록 구성되었는지 검증한다. ",
    "Check_sql": null,
    "Fix": "Windows가 비-기밀분류 정보에 KISA-인정 알고리즘을 사용하도록 구성한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79311",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "시스템 SQL Server는 감사 데이터를 별개 로그 관리 설비로 외부 저장해야 한다; 단독 시스템일 경우에는 더 자주 매주 수행하고 스토리지 설비와 네트워크 연결을 가진 시스템에 지속적이고 근-실시간으로 수행되어야 한다.",
    "Check": "감사 레코드를 외부 저장하는 방법을 설명한 시스템 문서를 검토한다. 만일 시스템이 중앙집중 로그 관리 시스템에 지속적인 네트워크 연결을 가지지만, DBMS 감사 레코드가 중앙집중 로그 관리 시스템에 직접적으로 쓰여지고 근-실시간으로 전송된다면, 조치가 필요하다. 만일 시스템이 중앙집중 로그 관리 시스템과 지속적인 네트워크 연결을 가지지 않고, DBMS 감사 레코드가 매주나 더 자주 중앙집중 로그 관리 시스템으로 전송되지 않는다면, 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "로그 관리 시스템의 지속적인 네트워크 연결이 존재하면 지속적으로 근-실시간으로(존재하지 않는다면 최소 매주) 중앙집중 로그 관리 시스템에 감사 레코드를 전송하는 소프트웨어 툴을 적용하고 시스템을 구성한다.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79313",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 “Customer Feedback”과 “Error Reporting”을 구성해야 한다. ",
    "Check": "레지스트리 편집기 “regedit”를 실행한다. “HKEY_LOCAL_MACHINE\\Software\\MS\\MS SQL Server\\[InstanceId]\\CPE”를 찾는다. 다음 값을 확인한다: “CustomerFeedback, EnableErrorReporting”. “HKEY_LOCAL_MACHINE\\Software\\MS\\MS SQL Server\\130”를 찾는다. 다음 값을 확인한다: “CustomerFeedback, EnableErrorReporting”. 만일 기밀분류 시스템이고, 위에서 언급된 값이 “0”dl 아니라면, 조치가 필요하다. 만일 기밀분류 시스템이 아니라면, CEIP 파티션이 인가 받았는지 여부를 판단하기 위해 서버 문서를 검토한다. 만일 CEIP 파티션이 인가 받지 않았고, 위에서 언급된 값이 “1”이라면, 조치가 필요하다. ",
    "Check_sql": null,
    "Fix": "CEIP 프로그램에서 파티션을 비활성화 하려면, 다음 레지스트리 값을 “0”으로 설정한다. CEIP 프로그램에서 파티션을 활성화 하려면, 다음 레지스트리 값을 “1”로 설정한다. “HKEY_LOCAL_MACHINE\\Software\\MS\\MS SQL Server\\[InstanceId]\\CPE\\CustomerFeedback, HKEY_LOCAL_MACHINE\\Software\\MS\\MS SQL Server\\[InstanceId]\\CPE\\EnableErrorReporting, HKEY_LOCAL_MACHINE\\Software\\MS\\MS SQL Server\\130\\CustomerFeedback, HKEY_LOCAL_MACHINE\\Software\\MS\\MS SQL Server\\130\\EnableErrorReporting”.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79315",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "CDMDB는 “SQL Server Usage”와 “Error Reporting Auditing”를 구성해야 한다.",
    "Check": "원격-측정 데이터의 감사가 필요한지 판단하기 위해 서버 문서를 검토한다. 만일 원격-측정 데이터의 감사가 필요하지 않다면, 조치가 필요하지 않다. 만일 원격-측정 데이터의 감사가 필요하다면, 다음 쿼리를 실행하여 원격-측정 서비스 사용자 이름을 판단한다: “SELECT name FROM sys.server_principals WHERE name LIKE '%SQLTELEMETRY%';”. 다음 레지스트리 키 값을 확인한다: “HKEY_LOCAL_MACHINE\\SOFTWARE\\MS\\MS SQL Server\\[InstanceId]\\CPE\\UserRequestedLocalAuditDirectory”. 주: InstanceId는 기능의 유형과 인스턴스를 말한다(예, MSSQL13.SqlInstance, MSAS13.SSASInstance, MSRS13.SSRSInstance). 만일 레지스트리 키가 존재하지 않거나 값이 빈칸이라면, 조치가 필요하지 않다. 파일 탐색기에서 \"UserRequestedLocalAuditDirectory\" 레지스트리 키에 정의된 경로를 조회한다. 폴더를 오른쪽-클릭 >> “Properties”를 선택 >> “Security” 탭을 선택. “QLTELEMETRY” 계정이 다음 허가를 가졌는지 검증한다: “- List folder contents - Read – Write”. 만일 허가가 폴더에 적절하게 설정되지 않았다면, 조치가 필요하다. “services.msc”를 오픈 하고 원격-측정 서비스를 찾는다: “- 데이터베이스 엔진인 경우, SQL Server CEIP Services <INSTANCENAME>)를 사용 – 분석 서비스인 경우, SQL Server Analysis Services CEIP <INSTANCENAME>)를 사용” 서비스를 오른쪽-클릭하고 “Properties”를 선택한다. “Startup type”이 “Automatic”인지 검증한다. 만일 서비스가 자동적으로 시작하도록 구성되지 않았다면, 조치가 필요하다. 원격-측정 데이터를 검토하는 프로세스/절차를 검토한다. 만일 원격-측정 데이터가 프로세스/절차에 따라 정기적으로 검토된다는 증거가 있다면, 조치가 필요하지 않다. 만일 원격-측정 데이터를 검토하는 프로세스/절차가 존재하지 않는다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name FROM sys.server_principals WHERE name LIKE '%SQLTELEMETRY%';"
    ],
    "Fix": "원격-측정 데이터를 감사하도록 데이터베이스를 구성한다. 원격-측정 데이터의 감사에 관한 상세한 정보는 “https://msdn.MS.com/en-us/library/mt743085.aspx”를 참조하기 바란다. 원격-측정 감사 데이터를 저장하는 폴더를 생성한다. 폴더에 다음 허가로 “SQLTELEMETRY”를 허가한다: “- List folder contents - Read – Write”. 다음 레지스트리 키를 생성하고 구성한다: “HKEY_LOCAL_MACHINE\\SOFTWARE\\MS\\MS SQL Server\\[InstanceId]\\CPE\\UserRequestedLocalAuditDirectory [string]” 주: InstanceId는 기능의 유형과 인스턴스를 말한다(예, MSSQL13.SqlInstance, MSAS13.SSASInstance, MSRS13.SSRSInstance). \"UserRequestedLocalAuditDirectory\" 키 값을 원격-측정 감사 폴더 경로로 설정한다. 원격-측정 서비스를 자동적으로 시작하도록 설정한다. 서비스를 재시작한다. “- 데이터베이스 엔진인 경우, SQL Server CEIP Services <INSTANCENAME>)를 사용 – 분석 서비스인 경우, SQL Server Analysis Services CEIP <INSTANCENAME>)를 사용”.",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79317",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "SQL Server 디폴트 계정 [sa]는 비활성화 되어야 한다.",
    "Check": "디폴트 계정 [sa]가 비활성화 되었는지 여부를 판단하기 위해 SQL Server 설정을 확인한다. 다음 쿼리를 실행한다: “USE master; GO SELECT name, is_disabled FROM sys.sql_logins WHERE principal_id = 1; GO”. “name” 컬럼이 [sa] 데이터베이스 서버 계정 이름을 가졌는지 검증한다. 만일 “is_disabled” 컬럼이 “1”로 설정되지 않았다면, 조치가 필요하다. ",
    "Check_sql": [
      "USE master;",
      "GO SELECT name, is_disabled FROM sys.sql_logins WHERE principal_id = 1;",
      "GO;"
    ],
    "Fix": "다음 스크립트를 실행하여, [sa] 계정의 활성화된 플래그를 변경한다: “USE master; GO ALTER LOGIN [sa] DISABLE; GO”.",
    "Fix_sql": [
      "USE master;",
      "GO ALTER LOGIN [sa] DISABLE;",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79319",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "SQL Server 디폴트 계정 [sa]는 이름이 변경되어야 한다.",
    "Check": "SQL Server 디폴트 계정 이름 [sa]는 다음 쿼리를 실행하여 변경되어야 한다: “USE master; GO SELECT * FROM sys.sql_logins WHERE [name] = 'sa' OR [principal_id] = 1; GO”. 만일 쿼리 결과에 로그인 계정 이름 “SA”/”sa”가 나타난다면, 조치가 필요하다.",
    "Check_sql": [
      "USE master;",
      "GO SELECT * FROM sys.sql_logins WHERE [name] = 'sa' OR [principal_id] = 1;",
      "GO;"
    ],
    "Fix": "다음 스크립트를 실행하여 [sa] 계정을 변경한다: “USE master; GO ALTER LOGIN [sa] WITH NAME = <new name> GO”.",
    "Fix_sql": [
      "USE master;",
      "GO ALTER LOGIN [sa] WITH NAME = <new name> GO;"
    ]
  },
  {
    "Id": "CDMV-79321",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "스타트업 스토어드 프로시저는 필요한 경우 만으로 제한되어야 한다. ",
    "Check": "시작 시에 SQL Server가 사용하는 문서화된 스토어드 프로시저 목록을 입수하기 위해 시스템 문서를 검토한다. 다음 쿼리를 실행한다: “Select [name] as StoredProc From sys.procedures Where OBJECTPROPERTY(OBJECT_ID, 'ExecIsStartup') = 1;”. 만일 문서화되지 않은 스토어드 프로시저가 리턴 된다면, 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "스타트업 스토어드 프로시저를 비활성화 하기 위해, 각 문서화 되지 않은 프로시저에 다음 쿼리를 실행한다: “sp_procoption @procname = '<procedure name>', @OptionName = 'Startup', @optionValue = 'Off'”.",
    "Fix_sql": [
      "sp_procoption @procname = '<procedure name>', @OptionName = 'Startup', @optionValue = 'Off';"
    ]
  },
  {
    "Id": "CDMV-79323",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "SQL Server “Mirroring” 종단점은 AES 암호를 사용해야 한다.",
    "Check": "만일 데이터 소유자가 데이터 무결성/기밀성이 데이터 전송/처리 프로세스의 매번 단계에서 유지 관리되도록 보장하는 엄격한 요구사항을 가지지 않고, 요구사항이 문서화되고 인가 받았다면, 조치가 필요하지 않다. 만일 “Database Mirroring”이 사용된다면, 암호화된 전송을 확인하기 위해 다음 쿼리를 실행한다: “SELECT name, type_desc, encryption_algorithm_desc FROM sys.database_mirroring_endpoints WHERE encryption_algorithm != 2;”. 만일 어떤 레코드가 리턴 된다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT name, type_desc, encryption_algorithm_desc FROM sys.database_mirroring_endpoints WHERE encryption_algorithm != 2;"
    ],
    "Fix": "미러링 종단점에 암호를 활성화 하기 위해 다음 쿼리를 실행한다: “ALTER ENDPOINT <Endpoint Name> FOR DATABASE_MIRRORING (ENCRYPTION = REQUIRED ALGORITHM AES);”.",
    "Fix_sql": [
      "ALTER ENDPOINT <Endpoint Name> FOR DATABASE_MIRRORING (ENCRYPTION = REQUIRED ALGORITHM AES);"
    ]
  },
  {
    "Id": "CDMV-79325",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "SQL Server “Service Broker” 종단점은 AES 암호를 사용해야 한다.",
    "Check": "만일 데이터 소유자가 데이터 무결성/기밀성이 데이터 전송/처리 프로세스의 매번 단계에서 유지 관리되도록 보장하는 엄격한 요구사항을 가지지 않고, 요구사항이 문서화되고 인가 받았다면, 조치가 필요하지 않다. 만일 “SQL Service Broker”가 사용된다면, 암호화된 전송을 확인하기 위해 다음 쿼리를 실행한다: “SELECT name, type_desc, encryption_algorithm_desc FROM sys.service_broker_endpoints WHERE encryption_algorithm != 2;”. 만일 어떤 레코드가 리턴 된다면, 조치가 필요하다. ",
    "Check_sql": [
      "SELECT name, type_desc, encryption_algorithm_desc FROM sys.service_broker_endpoints WHERE encryption_algorithm != 2;"
    ],
    "Fix": "“Service Broker” 종단점의 암호화를 활성화 하기 위해 다음 쿼리를 실행한다: “ALTER ENDPOINT <EndpointName> FOR SERVICE_BROKER (ENCRYPTION = REQUIRED ALGORITHM AES);”.",
    "Fix_sql": [
      "ALTER ENDPOINT <EndpointName> FOR SERVICE_BROKER (ENCRYPTION = REQUIRED ALGORITHM AES);"
    ]
  },
  {
    "Id": "CDMV-79327",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "레지스트리를 접근하는 SQL Server 실행 허가가 명확하게 필요하고 승인되지 않는 한 철회되어야 한다.",
    "Check": "레지스트리 확장 스토어드 프로시저는 SQL Server가 레지스트리의 값과 키를 읽기/쓰기/열거하도록 허용한다. 서버를 구성하기 위해 Enterprise Manager에 의해 사용된다. 이 규칙은 레지스트리 확장 스토어드 프로시저를 실행하는 허가가 모든 사용자(dbo제외)로부터 철회되었는지 확인한다: SELECT OBJECT_NAME(major_id) AS [Stored Procedure],dpr.NAME AS [Principal] FROM sys.database_permissions AS dp INNER JOIN sys.database_principals AS dpr ON dp.grantee_principal_id = dpr.principal_id WHERE major_id IN ( OBJECT_ID('xp_regaddmultistring'), OBJECT_ID('xp_regdeletekey'),OBJECT_ID('xp_regdeletevalue'),OBJECT_ID('xp_regenumvalues'),OBJECT_ID('xp_regenumkeys'),OBJECT_ID('xp_regread'),OBJECT_ID('xp_regremovemultistring'),OBJECT_ID('xp_regwrite'),OBJECT_ID('xp_instance_regaddmultistring'),OBJECT_ID('xp_instance_regdeletekey'),OBJECT_ID('xp_instance_regdeletevalue'),OBJECT_ID('xp_instance_regenumkeys'),OBJECT_ID('xp_instance_regenumvalues'),OBJECT_ID('xp_instance_regread'),OBJECT_ID('xp_instance_regremovemultistring'),OBJECT_ID('xp_instance_regwrite') ) AND dp.[type] = 'EX' ORDER BY dpr.NAME;”. 만일 어떤 레코드가 리턴 된다면, 확장 스토어드 프로시저를 통한 레지스트리 접근이 필요하고 승인되는지 여부를 판단하기 위해 시스템을 검토한다. 만일 인가 받지 않았다면, 조치가 필요하다.",
    "Check_sql": [
      "SELECT OBJECT_NAME(major_id) AS [Stored Procedure],dpr.NAME AS [Principal] FROM sys.database_permissions AS dp INNER JOIN sys.database_principals AS dpr ON dp.grantee_principal_id = dpr.principal_id WHERE major_id IN ( OBJECT_ID('xp_regaddmultistring'), OBJECT_ID('xp_regdeletekey'),OBJECT_ID('xp_regdeletevalue'),OBJECT_ID('xp_regenumvalues'),OBJECT_ID('xp_regenumkeys'),OBJECT_ID('xp_regread'),OBJECT_ID('xp_regremovemultistring'),OBJECT_ID('xp_regwrite'),OBJECT_ID('xp_instance_regaddmultistring'),OBJECT_ID('xp_instance_regdeletekey'),OBJECT_ID('xp_instance_regdeletevalue'),OBJECT_ID('xp_instance_regenumkeys'),OBJECT_ID('xp_instance_regenumvalues'),OBJECT_ID('xp_instance_regread'),OBJECT_ID('xp_instance_regremovemultistring'),OBJECT_ID('xp_instance_regwrite') ) AND dp.[type] = 'EX' ORDER BY dpr.NAME;"
    ],
    "Fix": "모든 사용자(dbo 제외)레지스트리 확장 스토어드 프로시저의 실행 허가를 삭제한다: “USE master GO REVOKE EXECUTE ON [xp_regread] FROM public GO”.",
    "Fix_sql": [
      "USE master GO REVOKE EXECUTE ON [xp_regread] FROM public GO;"
    ]
  },
  {
    "Id": "CDMV-79329",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "SQL Server “Filestream” 기능이 명확하게 필요하고 승인되지 않는 한 비활성화 되어야 한다.",
    "Check": "“FileStream”이 사용되는지 확인하기 위해 시스템 문서를 검토한다. 만일 사용을 인가 받았다면, 조치가 필요하지 않다. 만일 “FileStream”이 필요하고 인가 받은 것으로 문서화 되지 않았다면, 다음 쿼리를 실행한다: “EXEC sp_configure 'filestream access level'. 만일 “run_value”가 “0” 보다 크다면, 조치가 필요하다. 이 규칙은 “File Stream” SQL 특정 옵션이 비활성화인지 확인한다: “SELECT CASE WHEN EXISTS (SELECT * FROM sys.configurations WHERE Name = 'filestream access level' AND Cast(value AS INT) = 0) THEN 'No' ELSE 'Yes' END AS TSQLFileStreamAccess;”. 만일 “FileStreamEnabled” 필드의 리턴값이 “Yes”이면, 조치가 필요하다.",
    "Check_sql": [
      "EXEC sp_configure 'filestream access level'. 만일 “run_value;",
      "SELECT CASE WHEN EXISTS (SELECT * FROM sys.configurations WHERE Name = 'filestream access level' AND Cast(value AS INT) = 0) THEN 'No' ELSE 'Yes' END AS TSQLFileStreamAccess;"
    ],
    "Fix": "“Filestream” 기능을 비활성화 한다: 1) 모든 테이블에서 모든 FILESTREAM 컬럼을 삭제한다: “ALTER TABLE <name> DROP COLUMN <column name>;”. 2) FILESTREAM filegroups로부터 테이블을 관계-해제 한다. “ALTER TABLE <name> SET (FILESTREAM_ON = 'NULL';”. 3) 모든 FILESTREAM 데이터 컨테이너를 삭제한다: “ALTER DATABASE <name> REMOVE FILE <file name>;”. 4) 모든 FILESTREAM filegroups를 삭제한다: “ALTER DATABASE <name> REMOVE FILEGROUP <file name>;”. 5) FILESTREAM 기능을 비활성화 한다: “EXEC sp_configure filestream_access_level, 0 RECONFIGURE”. SQL 서비스를 재시작한다.",
    "Fix_sql": [
      "ALTER TABLE <name> DROP COLUMN <column name>;",
      "ALTER TABLE <name> SET (FILESTREAM_ON = 'NULL';",
      "ALTER DATABASE <name> REMOVE FILE <file name>;",
      "ALTER DATABASE <name> REMOVE FILEGROUP <file name>;",
      "EXEC sp_configure filestream_access_level, 0 RECONFIGURE;"
    ]
  },
  {
    "Id": "CDMV-79333",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "SQL Server “Ole Automation Procedures” 기능이 명확하게 필요하고 승인되지 않는 한 비활성화 되어야 한다.",
    "Check": "“Ole Automation Procedures” 옵션이 활성화되었는지 여부를 판단하기 위해, 다음 쿼리를 실행한다: “EXEC SP_CONFIGURE 'show advanced options', '1'; RECONFIGURE WITH OVERRIDE; EXEC SP_CONFIGURE ' Ole Automation Procedures';”. 만일 “config_value” 값이 “0”이라면, 조치가 필요하지 않다. 만일 “config_value” 값이 “1”이라면, “Ole Automation Procedures” 이 필요하고 인가 받았는지 여부를 판단하기 위해 시스템 문서를 검토하고, 만일 인가 받지 않았다면, 조치가 필요하다.",
    "Check_sql": [
      "EXEC SP_CONFIGURE 'show advanced options', '1';",
      "RECONFIGURE WITH OVERRIDE;",
      "EXEC SP_CONFIGURE ' Ole Automation Procedures';"
    ],
    "Fix": "인가 받지 않은 외부 애플리케이션 실행 오브젝트 정의를 제거하거나 비활성화 한다. “Ole Automation Procedures” 옵션을 비활성화 하려면, 다음 쿼리를 실행한다: “sp_configure 'show advanced options', 1; GO RECONFIGURE; GO sp_configure 'Ole Automation Procedures’, 0; GO RECONFIGURE; GO”.",
    "Fix_sql": [
      "sp_configure 'show advanced options', 1;",
      "GO RECONFIGURE;",
      "GO sp_configure 'Ole Automation Procedures’, 0;",
      "GO RECONFIGURE;",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79335",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "SQL Server “User Options” 기능이 명확하게 필요하고 승인되지 않는 한 비활성화 되어야 한다.",
    "Check": "“User Options” 옵션이 활성화되었는지 여부를 판단하기 위해, 다음 쿼리를 실행한다: “EXEC SP_CONFIGURE 'show advanced options', '1'; RECONFIGURE WITH OVERRIDE; EXEC SP_CONFIGURE 'user options';”. 만일 “config_value” 값이 “0”이라면, 조치가 필요하지 않다. 만일 “config_value” 값이 “1”이라면, “User Options” 이 필요하고 인가 받았는지 여부를 판단하기 위해 시스템 문서를 검토하고, 만일 인가 받지 않았다면, 조치가 필요하다.",
    "Check_sql": [
      "EXEC SP_CONFIGURE 'show advanced options', '1';",
      "RECONFIGURE WITH OVERRIDE;",
      "EXEC SP_CONFIGURE 'user options';"
    ],
    "Fix": "인가 받지 않은 외부 애플리케이션 실행 오브젝트 정의를 제거하거나 비활성화 한다. “User Options” 옵션을 비활성화 하려면, 다음 쿼리를 실행한다: “sp_configure 'show advanced options', 1; GO RECONFIGURE; GO sp_configure 'user options', 0; GO RECONFIGURE; GO”.",
    "Fix_sql": [
      "sp_configure 'show advanced options', 1;",
      "GO RECONFIGURE;",
      "GO sp_configure 'user options', 0;",
      "GO RECONFIGURE;",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79337",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "SQL Server “Remote Access” 기능이 명확하게 필요하고 승인되지 않는 한 비활성화 되어야 한다.",
    "Check": "“Remote Access” 옵션이 활성화되었는지 여부를 판단하기 위해, 다음 쿼리를 실행한다: “EXEC SP_CONFIGURE 'show advanced options', '1'; RECONFIGURE WITH OVERRIDE; EXEC SP_CONFIGURE 'remote access';”. 만일 “config_value” 값이 “0”이라면, 조치가 필요하지 않다. 만일 “config_value” 값이 “1”이라면, \"Remote Access\" 가 필요하고(서버 연결) 인가 받았는지 여부를 판단하기 위해 시스템 문서를 검토하고, 만일 인가 받지 않았다면, 조치가 필요하다.",
    "Check_sql": [
      "EXEC SP_CONFIGURE 'show advanced options', '1';",
      "RECONFIGURE WITH OVERRIDE;",
      "EXEC SP_CONFIGURE 'remote access';"
    ],
    "Fix": "인가 받지 않은 외부 애플리케이션 실행 오브젝트 정의를 제거하거나 비활성화 한다. “Remote Access” 옵션을 비활성화 하려면, 다음 쿼리를 실행한다: “sp_configure 'show advanced options', 1; GO RECONFIGURE; GO sp_configure 'remote access', 0; GO RECONFIGURE; GO”.",
    "Fix_sql": [
      "sp_configure 'show advanced options', 1;",
      "GO RECONFIGURE;",
      "GO sp_configure 'remote access', 0;",
      "GO RECONFIGURE;",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79341",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "SQL Server “Hadoop Connectivity” 기능이 명확하게 필요하고 승인되지 않는 한 비활성화 되어야 한다.",
    "Check": "“Hadoop Connectivity” 옵션이 활성화되었는지 여부를 판단하기 위해, 다음 쿼리를 실행한다: “EXEC SP_CONFIGURE 'show advanced options', '1'; RECONFIGURE WITH OVERRIDE; EXEC SP_CONFIGURE 'hadoop connectivity';”. 만일 “config_value” 값이 “0”이라면, 조치가 필요하지 않다. 만일 “config_value” 값이 “1”이라면, “Hadoop Connectivity”가 필요하고 인가 받았는지 여부를 판단하기 위해 시스템 문서를 검토하고, 만일 인가 받지 않았다면, 조치가 필요하다. ",
    "Check_sql": [
      "EXEC SP_CONFIGURE 'show advanced options', '1';",
      "RECONFIGURE WITH OVERRIDE;",
      "EXEC SP_CONFIGURE 'hadoop connectivity';"
    ],
    "Fix": "인가 받지 않은 외부 애플리케이션 실행 오브젝트 정의를 제거하거나 비활성화 한다. “Hadoop Connectivity” 옵션을 비활성화 하려면, 다음 쿼리를 실행한다: “sp_configure 'show advanced options', 1; GO RECONFIGURE; GO sp_configure 'hadoop connectivity', 0; GO RECONFIGURE; GO”.",
    "Fix_sql": [
      "sp_configure 'show advanced options', 1;",
      "GO RECONFIGURE;",
      "GO sp_configure 'hadoop connectivity', 0;",
      "GO RECONFIGURE;",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79343",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "SQL Server “Allow Polybase Export” 기능이 명확하게 필요하고 승인되지 않는 한 비활성화 되어야 한다.",
    "Check": "“Allow Polybase Export” 옵션이 활성화되었는지 여부를 판단하기 위해, 다음 쿼리를 실행한다: “EXEC SP_CONFIGURE 'show advanced options', '1'; RECONFIGURE WITH OVERRIDE; EXEC SP_CONFIGURE 'allow polybase export';”. 만일 “config_value” 값이 “0”이라면, 조치가 필요하지 않다. 만일 “config_value” 값이 “1”이라면, “Allow Polybase Export”가 필요하고 인가 받았는지 여부를 판단하기 위해 시스템 문서를 검토하고, 만일 인가 받지 않았다면, 조치가 필요하다. ",
    "Check_sql": [
      "EXEC SP_CONFIGURE 'show advanced options', '1';",
      "RECONFIGURE WITH OVERRIDE;",
      "EXEC SP_CONFIGURE 'allow polybase export';"
    ],
    "Fix": "인가 받지 않은 외부 애플리케이션 실행 오브젝트 정의를 제거하거나 비활성화 한다. “Allow Polybase Export” 옵션을 비활성화 하려면, 다음 쿼리를 실행한다: “sp_configure 'show advanced options', 1; GO RECONFIGURE; GO sp_configure 'allow polybase export', 0; GO RECONFIGURE; GO”.",
    "Fix_sql": [
      "sp_configure 'show advanced options', 1;",
      "GO RECONFIGURE;",
      "GO sp_configure 'allow polybase export', 0;",
      "GO RECONFIGURE;",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79345",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "SQL Server “Remote Data Archive” 기능이 명확하게 필요하고 승인되지 않는 한 비활성화 되어야 한다.",
    "Check": "“Remote Data Archive” 옵션이 활성화되었는지 여부를 판단하기 위해, 다음 쿼리를 실행한다: “EXEC SP_CONFIGURE 'show advanced options', '1'; RECONFIGURE WITH OVERRIDE; EXEC SP_CONFIGURE 'remote data archive';”. 만일 “config_value” 값이 “0”이라면, 조치가 필요하지 않다. 만일 “config_value” 값이 “1”이라면, “Remote Data Archive”가 필요하고 인가 받았는지 여부를 판단하기 위해 시스템 문서를 검토하고, 만일 인가 받지 않았다면, 조치가 필요하다.",
    "Check_sql": [
      "EXEC SP_CONFIGURE 'show advanced options', '1';",
      "RECONFIGURE WITH OVERRIDE;",
      "EXEC SP_CONFIGURE 'remote data archive';"
    ],
    "Fix": "인가 받지 않은 외부 애플리케이션 실행 오브젝트 정의를 제거하거나 비활성화 한다. “Remote Data Archive” 옵션을 비활성화 하려면, 다음 쿼리를 실행한다: “sp_configure 'show advanced options', 1; GO RECONFIGURE; GO sp_configure 'remote data archive', 0; GO RECONFIGURE; GO”.",
    "Fix_sql": [
      "sp_configure 'show advanced options', 1;",
      "GO RECONFIGURE;",
      "GO sp_configure 'remote data archive', 0;",
      "GO RECONFIGURE;",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79347",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "SQL Server “External Scripts Enabled” 기능이 명확하게 필요하고 승인되지 않는 한 비활성화 되어야 한다.",
    "Check": "“External Scripts Enabled” 옵션이 활성화 되었는지 판단하기 위해, 다음 쿼리를 실행한다: “EXEC SP_CONFIGURE 'show advanced options', '1'; RECONFIGURE WITH OVERRIDE; EXEC SP_CONFIGURE 'external scripts enabled';”. 만일 “config_value” 값이 “0”이면, 조치가 필요하지 않다. 만일 “config_value” 값이 “1”이라면, “External Scripts Enabled”가 필요하고 인가 받았는지 여부를 판단하기 위해 시스템 문서를 검토한다. 만일 인가 받지 않았다면, 조치가 필요하다.",
    "Check_sql": [
      "EXEC SP_CONFIGURE 'show advanced options', '1';",
      "RECONFIGURE WITH OVERRIDE;",
      "EXEC SP_CONFIGURE 'external scripts enabled';"
    ],
    "Fix": "인가 받지 않은 외부 애플리케이션 실행 오브젝트 정의를 제거하고 비활성화 한다. “External Scripts Enabled” 옵션을 비활성화 하려면, 다음 쿼리를 실행한다: “sp_configure 'show advanced options', 1; GO RECONFIGURE; GO sp_configure 'external scripts enabled', 0; GO RECONFIGURE; GO”.",
    "Fix_sql": [
      "sp_configure 'show advanced options', 1;",
      "GO RECONFIGURE;",
      "GO sp_configure 'external scripts enabled', 0;",
      "GO RECONFIGURE;",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79349",
    "Risk": "L",
    "Status": "Ready",
    "Subject": "SQL Server “Browser” 서비스가 명확하게 필요하고 승인되지 않는 한 비활성화 되어야 한다.",
    "Check": "만일 SQL Server Browser 서비스의 필요성이 문서화 되고 인가 받았다면, 조치가 필요하지 않다. Windows 시작 >> 제어판 >> “관리 도구” >> “서비스”나 명령 프롬프트에서 “services.msc”를 입력하고 “Enter” 키 >> “SQL Server Brower”를 찾고 >> 시작 유형이 “사용 안 함”이 아니면, 조치가 필요하다. ",
    "Check_sql": null,
    "Fix": "만일 SQL Server Browser가 필요하다면, 근거를 문서화 하고 적절한 인가를 받는다. SQL Server Browser가 필요하지 않다고 판단되면, 서비스는 비활성화 될 수 있다. 비활성화 하려면, Windows 시작 >> 제어판 >> “관리 도구” >> “서비스” >> “SQL Server Browser”를 찾고 “시작 유형”을 “사용 안 함”으로 설정한다. 만일 “상태”가 “실행 중”이라면 더블-클릭하고 “중지(T)” 버튼을 클릭한다",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79351",
    "Risk": "M",
    "Status": "Ready",
    "Subject": "SQL Server “Replication Xps” 기능이 명확하게 필요하고 승인되지 않는 한 비활성화 되어야 한다.",
    "Check": "“Replication Xps” 옵션이 비활성화 되었는지 판단하기 위해 다음 쿼리를 실행한다: “EXEC SP_CONFIGURE 'show advanced options', '1'; RECONFIGURE WITH OVERRIDE; EXEC SP_CONFIGURE 'replication xps';”. 만일 “config_value”의 값이 “0”이면, 조치가 필요하지 않다. 만일 “config_value”의 값이 “1”이면, “Replication Xps” 사용이 필요하고 승인되는지 여부를 판단하기 위해 시스템 문서를 검토한다. 만일 인가 받지 않았다면, 조치가 필요하다.  ",
    "Check_sql": [
      "EXEC SP_CONFIGURE 'show advanced options', '1';",
      "RECONFIGURE WITH OVERRIDE;",
      "EXEC SP_CONFIGURE 'replication xps';"
    ],
    "Fix": "인가 받지 않은 외부 애플리케이션 실행 오브젝트 정의를 제거하거나 비활성화 한다. 다음 쿼리로 “Replication Xps” 옵션 사용을 비활성화 한다: “sp_configure 'show advanced options', 1; GO RECONFIGURE; GO sp_configure 'replication xps', 0; GO RECONFIGURE; GO”.",
    "Fix_sql": [
      "sp_configure 'show advanced options', 1;",
      "GO RECONFIGURE;",
      "GO sp_configure 'replication xps', 0;",
      "GO RECONFIGURE;",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79353",
    "Risk": "L",
    "Status": "Ready",
    "Subject": "만일 SQL Server “Browser” 서비스가 명확하게 필요하고 승인된다면, CDMDB는 숨겨져야 한다. ",
    "Check": "만일 SQL Server “Browser” 서비스가 문서화 되고 인가되었다면, 다음 쿼리로 CDMDB가 숨겨졌는지 확인한다: “DECLARE @HiddenInstance INT EXEC master.dbo.Xp_instance_regread N'HKEY_LOCAL_MACHINE',  N'Software\\MS\\MSSQLServer\\MSSQLServer\\SuperSocketNetLib',  N'HideInstance', @HiddenInstance output;, SELECT CASE WHEN @HiddenInstance = 0 AND Serverproperty('IsClustered') = 0 THEN 'No' ELSE 'Yes' END AS [Hidden];”. 만일 “Hidden” 값이 “Yes”이면, 조치가 필요하지 않다. 만일 “Hidden” 값이 “No”이고 “SQL Server Browser” 서비스 시작 유형이 “Disabled”가 아니라면, 조치가 필요하다.",
    "Check_sql": [
      "DECLARE @HiddenInstance INT EXEC master.dbo.Xp_instance_regread N'HKEY_LOCAL_MACHINE',  N'Software\\MS\\MSSQLServer\\MSSQLServer\\SuperSocketNetLib',  N'HideInstance', @HiddenInstance output;",
      "SELECT CASE WHEN @HiddenInstance = 0 AND Serverproperty('IsClustered') = 0 THEN 'No' ELSE 'Yes' END AS [Hidden];"
    ],
    "Fix": "만일 SQL Server “Browser”가 필요하면, 근거를 문서화 하고 적절한 인가를 받는다. CDMDB를 숨기기 위해, SSCM에서, SQL Server Network Configuration 확장 >> <server instance> Protocols 오른쪽 클릭 >> “Flags” 탭에서 “Properties” 선택 >> “HideInstance” 박스에서 “Yes” 선택 >> “OK” 클릭. 신규 연결이 생성되면, 변경이 즉시 유효화 된다. ",
    "Fix_sql": null
  },
  {
    "Id": "CDMV-79355",
    "Risk": "H",
    "Status": "Ready",
    "Subject": "혼합-모드 인증 환경에서 “SQLCMD” 같은 명령줄 툴을 사용할 때, 사용자는 패스워드를 노출하지 않는 로그온 방법을 사용해야 한다.",
    "Check": "CDMDB 인증이 활성화되었는지 여부를 판단하기 위해 다음 쿼리를 실행한다: “EXEC master.sys.xp_loginconfig 'login mode';”. 만일 config_value 리턴값이 “Windows NT Authentication”이면, 조치가 필요하지 않다. SQLCMD에서 평문 패스워드를 허용하지 못하도록 구성할 수 없고, 다른 기본 툴이 동일한 제약을 가진다면, 시스템 문서가 툴의 필요성, 사용자 및 관련 완화 사항을 설명하는지 검증하고, 인증 담당자가 승인을 입수했는지 검증한다. 만일 그렇지 않다면, 조치가 필요하다. 툴의 모든 사용자가 평문 패스워드 옵션을 사용하지 않는 중요성, 패스워드를 숨기는 방법 및 이런 사례의 고수에 관해 훈련되었는지 증거(훈련 기록)를 요청한다. 만일 그렇지 않다면, 조치(훈련 실시)가 필요하다.",
    "Check_sql": [
      "EXEC master.sys.xp_loginconfig 'login mode';"
    ],
    "Fix": "가능하다면, 로그인 모드를 Windows-단독으로 변경한다: “USE [master] GO EXEC xp_instance_regwrite N'HKEY_LOCAL_MACHINE', N'Software\\MS\\MSSQLServer\\MSSQLServer', N'LoginMode', REG_DWORD, 1; GO”. 만일 혼합-모드 인증이 필요하다면, SQLCMD에서 혼합-모드 인증이 활성화 되고 평문 패스워드를 허용하지 않도록 구성 할 수 없고, 다른 기본 툴이 동일한 제약을 가진다면: 1) 필요성, 사용자, 관련 완화 사항을 문서화하고, 인증 담당자의 승인을 받는다. 2) 툴 사용자에게 평문 패스워드 옵션을 사용하지 않는 중요성, 패스워드를 숨기는 방법에 관하여 훈련시킨다. ",
    "Fix_sql": [
      "USE [master] GO EXEC xp_instance_regwrite N'HKEY_LOCAL_MACHINE', N'Software\\MS\\MSSQLServer\\MSSQLServer', N'LoginMode', REG_DWORD, 1;",
      "GO;"
    ]
  },
  {
    "Id": "CDMV-79357",
    "Risk": "H",
    "Status": "Ready",
    "Subject": "애플리케이션은 비인가 개인의 악용으로부터 정보를 보호하기 위해 인증 프로세스 동안에 인증 정보의 피드백을 모호화 해야 한다.",
    "Check": "CDMDB를 접근하는 애플리케이션이 계정 이름, 패스워드나 PIN을 허용하는지 여부를 판단한다. 만일 그렇다면, 이런 애플리케이션이 인증 데이터를 모호화 하는지 여부를 판단하고, 만일 그렇지 않다면, 조치가 필요하다.",
    "Check_sql": null,
    "Fix": "패스워드가 평문으로 보이지 않도록 애플리케이션을 구성하거나 수정한다. 즉, 패스워드에 관한 정보는 보이면 안 된다.",
    "Fix_sql": null
  }
]